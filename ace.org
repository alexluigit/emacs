#+TITLE: Emacs Configuration
#+AUTHOR: Alex Lu
#+EMAIL: alexluigit@gmail.com

* Overview

My Emacs configuration file written in org format.

** Init

'init' and 'early-init'

* Basic
** Custom utils (atom.el))

There are a few utilities that I keep re-using in various parts of my Emacs code base. To keep things modular, I place them all in a dedicated =atom.el= file, which can then be marked as a dependency by other libraries of mine. As such, all we here is load the file.

#+begin_src emacs-lisp
(use-package atom)
#+end_src

** Disable auto appending to init.el

When you install a package or use the various customisation interfaces to tweak things to your liking, Emacs will append a piece of Elisp to your init file. In my experience, this is a common source of inconsistencies, arising from a conflict between the user's code and what is stored in that custom snippet.

As it does not seem possible to outright disable this behaviour, I instruct Emacs to place all "custom" code in a temporary file that never gets loaded. This feels kinda hacky but is better than having some arbitrary code that you accidentally evaluated from messing up with your carefully designed (and version-controlled) configuration.

#+begin_src emacs-lisp
(use-package cus-edit
  :config
  (setq custom-file "/tmp/ace-emacs-custom.el"))
#+end_src

** Backups

#+begin_src emacs-lisp
(setq auto-save-default nil)
(setq make-backup-files nil)
(setq auto-save-list-file-prefix nil)
#+end_src

** History / State

This section contains configurations for packages that are dedicated to
the task of recording the state of various Emacs tools, such as the
history of the minibuffer or the list of recently visited files.

In practice, these are some of the most useful configurations one can
make, as lots of functions depend on them. For example, a record of the
minibuffer's history of inputs allows the completion framework to guess
the most likely course of action. Typing =M-x g= gives me =gnus= as the
first possible option, which is exactly what I want.

** Async facilities

This package provides some asynchronous processing facilities for
various Emacs interfaces, such as for Dired's copy and rename operations
(also read [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][Dired (directory editor, file manager)]]).

#+begin_src emacs-lisp
(use-package async)
#+end_src

** Simple (ace-simple.el)

=ace-simple.el= contains a wide range of commands that are broadly in line with the built-in =simple.el= and =lisp.el= libraries.

#+begin_src emacs-lisp
(use-package ace-simple
  :config
  (setq ace/simple-date-specifier "%F")
  (setq ace/simple-time-specifier "%R %z")
  :bind
  (("C-c i" . ace/simple-insert-date)
   ("C-c e" . ace/simple-escape-url)
   ("C-c q" . ace/simple-unfill-region-or-paragraph)
   ("C-<f2>" . ace/simple-rename-file-and-buffer)
   ("C-=" . count-words)
   ("<escape>" . keyboard-escape-quit)))
#+end_src

* Text Editing
** Evil

For text editing, I use =evil= mode, which stand for 'emacs vim emulation layer'
or something like that.

*** Basic (evil-mode.el)

#+begin_src emacs-lisp
(use-package evil
  :ensure t
  :init
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
  (setq evil-disable-insert-state-bindings t)
  (setq evil-want-Y-yank-to-eol t)
  (setq evil-want-C-u-scroll t)
  (setq evil-want-C-i-jump t)
  :config
  (evil-mode)
  (setq evil-echo-state nil)                      ;; We have state in modeline
  (setq evil-regexp-search t)                     ;; Use regex when search with '/' and '?'
  (setq-default evil-jumps-cross-buffers nil)     ;; Don't jump to other buffer when C-i/o
  (evil-global-set-key 'normal "p"           nil) ;; Need to be unbound first
  (evil-global-set-key 'motion "n"           #'evil-next-visual-line)
  (evil-global-set-key 'motion "p"           #'evil-previous-visual-line)
  (evil-global-set-key 'motion "k"           #'evil-paste-after)
  (evil-global-set-key 'motion "K"           #'evil-paste-before)
  (evil-global-set-key 'motion "N"           #'evil-join)
  (evil-global-set-key 'normal "P"           #'helpful-at-point)
  (evil-global-set-key 'normal "U"           #'evil-redo)
  (evil-global-set-key 'normal (kbd "C-.")   nil)
  (evil-global-set-key 'insert (kbd "C-u")   #'evil-delete-back-to-indentation)
  (evil-global-set-key 'insert (kbd "C-w")   #'evil-delete-backward-word)
  (evil-global-set-key 'insert (kbd "C-i")   #'backward-char)
  (evil-global-set-key 'insert (kbd "C-o")   #'forward-char)
  (evil-set-initial-state 'dired-mode 'emacs)
  (evil-set-initial-state 'vterm-mode 'emacs)
  (evil-set-initial-state 'eaf-mode 'emacs)
  :custom
  (evil-undo-system 'undo-redo))

(use-package ace-evil
  :after evil
  :config
  (setq ace/evil-visualstar-persistent nil)
  (ace/global-evil-visualstar-mode)
  (evil-global-set-key 'normal (kbd "<tab>") #'ace/evil-tab))
#+end_src

*** Evil Integration (evil-collection.el)

#+begin_src emacs-lisp
(use-package evil-collection
  :ensure t
  :after evil
  :config
  (defvar ace/intercept-mode-map (make-sparse-keymap)
    "High precedence keymap.")
  (define-minor-mode ace/intercept-mode
    "Global minor mode for higher precedence evil keybindings."
    :global t)
  (ace/intercept-mode)
  (dolist (state '(normal visual insert))
    (evil-make-intercept-map
     (evil-get-auxiliary-keymap ace/intercept-mode-map state t t) state))
  (evil-define-key 'normal ace/intercept-mode-map (kbd "C-n") 'evil-search-next)
  (evil-define-key 'normal ace/intercept-mode-map (kbd "C-p") 'evil-search-previous)
  (evil-collection-init '(rg vterm helpful help)))
#+end_src

*** Symbols pairs (evil-surround.el)

#+begin_src emacs-lisp
(use-package evil-surround
  :ensure t
  :config
  (global-evil-surround-mode 1))
#+end_src

*** Better 's' key (evil-snipe.el)

#+begin_src emacs-lisp
(use-package evil-snipe
  :ensure t
  :config
  (evil-snipe-mode +1) (evil-snipe-override-mode 1))
#+end_src

*** Pulse highlight (evil-goggles.el)

This is another package by Daniel Mendler which pulses the area where
some change took effect.  It is a subtle, yet effective, method to
visually capture the affected region of text and, thus, be confident
that no mistakes were made in the process (or notice those as they
occur).

#+begin_src emacs-lisp
(use-package evil-goggles
  :ensure t
  :config (evil-goggles-mode))
#+end_src

** Lines / Paragraphs (ace-fill.el)

The =ace-fill.el= library (reproduced below) is a tiny wrapper around
some Emacs settings and modes that are scrattered around several files,
which control (i) how paragraphs or comments in programming modes should
be wrapped to a given column count, and (ii) what constitutes a
sentence.  I put them all together here to make things easier to track.
+ With regard to paragraphs, I find that a double space is the best way
  to delimit sentences in source form, where a monospaced typeface is
  customary.  There is no worry that this will be shown on a website or
  rendered version of a document, because processors know how to handle
  spacing.  We do this to make phrases easier to tell apart, but also to
  render unambiguous commands like =forward-sentence=.
+ =ace/fill-fill-mode= sets my desired default column width for all
  buffers, while it applies another value for programming modes (in case
  there is a need to control the two cases separately).  Those values
  are stored in the variables =ace/fill-default-column= and
  =ace/fill-prog-mode-column= respectively.  My minor mode also enables
  =auto-fill-mode= in =text-mode= and =prog-mode= buffers through the
  appropriate hooks.  Disabling =ace/fill-fill-mode= will remove all
  those customisations.

#+begin_src emacs-lisp
(use-package ace-fill
  :config
  (setq-default truncate-lines nil)
  (setq ace/fill-default-column 80)
  (setq ace/fill-prog-mode-column 80)  ; Set this to another value if you want
  (setq sentence-end-double-space t)
  (setq sentence-end-without-period nil)
  (setq colon-double-space nil)
  (setq use-hard-newlines nil)
  (setq adaptive-fill-mode t)
  (ace/fill-fill-mode 1))
#+end_src

** Symbols (electric.el and paren.el)

Emacs labels as =electric= any behaviour that involves contextual
auto-insertion of characters.  This is a summary of my settings:

+ Indent automatically.
+ If =electric-pair-mode= is enabled (which I might do manually), insert
  quotes and brackets in pairs.  Only do so if there is no alphabetic
  character after the cursor.
  + To get those numbers, evaluate =(string-to-char CHAR)= where CHAR is
    the one you are interested in.  For example, get the literal tab's
    character with =(string-to-char "\t")=.
+ While inputting a pair, inserting the closing character will just skip
  over the existing one, rather than add a new one.  So typing =(= will
  insert =()= and then typing =)= will just be the same as moving forward
  one character =C-f=.
+ Do not skip over whitespace when operating on pairs.  Combined with
  the above point, this means that a new character will be inserted,
  rather than be skipped over.  I find this better, because it prevents
  the point from jumping forward, plus it allows for more natural
  editing.
+ The rest concern the conditions for transforming quotes into their
  curly equivalents.  I keep this disabled, because curly quotes are
  distinct characters.  It is difficult to search for them.  Just note
  that on GNU/Linux you can type them directly by hitting the "compose"
  key and then an angled bracket (=<= or =>=) followed by a quote mark.


#+begin_src emacs-lisp
(use-package electric
  :config
  (setq electric-pair-inhibit-predicate'electric-pair-conservative-inhibit)
  (setq electric-pair-preserve-balance t)
  (setq electric-pair-pairs
        '((8216 . 8217)
          (8220 . 8221)
          (171 . 187)))
  (setq electric-pair-skip-self 'electric-pair-default-skip-self)
  (setq electric-pair-skip-whitespace nil)
  (setq electric-pair-skip-whitespace-chars '(9 10 32))
  (setq electric-quote-context-sensitive t)
  (setq electric-quote-paragraph t)
  (setq electric-quote-string nil)
  (setq electric-quote-replace-double t)
  (electric-indent-mode 1)
  (electric-pair-mode 1)
  (electric-quote-mode -1))
#+end_src

** Tabs / indentation

I believe tabs, in the sense of inserting the tab character, are best
suited for indentation.  While spaces are superior at precisely aligning
text.  However, I understand that elisp uses its own approach, which I
do not want to interfere with.  Also, Emacs tends to perform alignments
by mixing tabs with spaces, which /can actually lead to misalignments/
depending on certain variables such as the size of the tab.  As such, I
am disabling tabs by default.

If there ever is a need to use different settings in other modes, we can
customise them via hooks.  This is not an issue I have encountered yet
and am therefore refraining from solving a problem that does not affect
me.

Note that =tab-always-indent= will first do indentation and then try to
complete whatever you have typed in.

#+begin_src emacs-lisp
(setq-default tab-always-indent 'complete)
(setq-default tab-first-completion 'word-or-paren-or-punct) ; Emacs 27
(setq-default tab-width 2)
(setq-default indent-tabs-mode nil)
(setq-default evil-shift-width tab-width)
#+end_src

** Search / Replace
*** Regular expressions (re-builder.el)

To learn more about regular expressions, read the relevant pages in
the official manual.  Assuming you have this installed properly on
your system, run =C-h r i regexp= to get to the starting chapter.

Also watch my ~35 minute-long [[https://protesilaos.com/codelog/2020-01-23-emacs-regexp-primer/][primer on Emacs regexp]] (2020-01-23).

Emacs offers a built-in package for practising regular expressions.
By default, =re-builder= uses Emacs-style escape notation, in the form
of double backslashes.  You can switch between the various styles by
using =C-c TAB= inside of the regexp builder's buffer.  I choose to keep
this style as the default.  Other options are =string= and =rx=.

#+begin_src emacs-lisp
(use-package re-builder
  :config
  (setq reb-re-syntax 'read))
#+end_src

*** Writable grep (wgrep.el)

With =wgrep= we can directly edit the results of a =grep= and save the
changes to all affected buffers.  In principle, this is the same as what
the built-in =occur= offers.  We can use it to operate on a list of
matches by leveraging the full power of Emacs' editing capabilities
(e.g. keyboard macros, query and replace a regexp...).

#+begin_src emacs-lisp
(use-package wgrep
  :config
  (setq wgrep-auto-save-buffer t)
  (setq wgrep-change-readonly-file t)
  ;; Press `dd' to delete lines in `wgrep-mode' in evil directly
  (defadvice evil-delete (around evil-delete-hack activate)
    ;; make buffer writable
    (if (and (boundp 'wgrep-prepared) wgrep-prepared)
        (wgrep-toggle-readonly-area))
    ad-do-it
    ;; make buffer read-only
    (if (and (boundp 'wgrep-prepared) wgrep-prepared)
        (wgrep-toggle-readonly-area)))
  :bind
  (:map wgrep-mode-map
        ("M-n" . next-error-no-select)
        ("M-p" . previous-error-no-select)))
#+end_src

*** Cross-references (xref.el)

Xref provides helpful commands for code navigation and discovery, such
as =xref-find-definitions= (=M-.=) and its counterpart =xref-pop-marker-stack=
(=M-,=).  It is a library that gets used by a variety of tools, including
=project.el= (see [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and ace/project.el)]]).

#+begin_src emacs-lisp
(use-package xref
  :config
  ;; All those have been changed for Emacs 28
  (setq xref-show-definitions-function #'xref-show-definitions-completing-read)
  (setq xref-show-xrefs-function #'xref-show-definitions-completing-read)
  (setq xref-file-name-display 'project-relative)
  (setq xref-search-program 'ripgrep))
#+end_src

*** Ripgrep (rg.el)

#+begin_src emacs-lisp
(use-package rg
  :ensure t
  :custom
  (rg-command-line-flags '("--context 3"))
  :config
  (rg-define-search ace/rg-project-dwim
    "Run ripgrep with every file (respect ignore) in current
project. Use word at point, no prompt."
    :files "everything"
    :query point
    :dir project))
#+end_src

* Interface / Interaction

General interface section including fontface/icon/etc function
definition.

** Better help info (helpful.el)

A better help buffer.

#+begin_src emacs-lisp
(use-package helpful
  :ensure t
  :config
  (let ((map global-map))
    (define-key map [remap describe-function] #'helpful-callable)
    (define-key map [remap describe-variable] #'helpful-symbol)
    (define-key map [remap describe-key] #'helpful-key)))
#+end_src

** Frame
*** Fringe-mode

#+begin_src emacs-lisp
(set-fringe-mode 10) ; Give some breathing room
(add-to-list 'default-frame-alist '(internal-border-width . 30))
#+end_src

*** Window divider

This is a built-in mode that draws vertical window borders in a slightly
different way than the default, which I find more consistent.  Only
using it because of that, though it can also adjust the size of the
# borders as well as their placement.

#+begin_src emacs-lisp
(setq window-divider-default-right-width 3)
(setq window-divider-default-bottom-width 3)
(setq window-divider-default-places 'right-only)
(add-hook 'after-init-hook #'window-divider-mode)
#+end_src

** Theme & icons

#+begin_src emacs-lisp
(use-package doom-themes
   :ensure t
  :config
  (load-theme 'doom-dracula t))

(use-package all-the-icons)
   :ensure t
#+end_src

** Better modeline (doom-modeline.el)

#+begin_src emacs-lisp
(use-package doom-modeline
  :ensure t
  :config
  (column-number-mode)
  (setq doom-modeline-height 28)
  (setq doom-modeline-major-mode-icon t)
  (doom-modeline-mode t))
#+end_src

** Fontface (ace-font.el)

#+begin_src emacs-lisp
(use-package ace-fonts
  :config
  (defun ace/set-font-faces ()
    (setq doom-modeline-icon t)
    (unless (file-exists-p "~/.local/share/fonts/all-the-icons.ttf")
      (all-the-icons-install-fonts t))
    (ace/font-set en-font-list ace/default-font-size zh-font-list 0.95)
    (set-face-attribute 'fixed-pitch nil :font "Victor Mono" :height ace/default-font-size)
    (set-face-attribute 'variable-pitch nil :font "Fira Code Retina" :height ace/default-variable-font-size :weight 'regular)
    (custom-set-faces '(font-lock-keyword-face ((t (:slant italic))))))

  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame)
                  (with-selected-frame frame (ace/set-font-faces))))
    (ace/set-font-faces)))
#+end_src

** Line Number

#+begin_src emacs-lisp
(global-display-line-numbers-mode t)
(dolist (mode '(org-mode-hook
                term-mode-hook
                shell-mode-hook
                treemacs-mode-hook
                eshell-mode-hook
                rg-mode-hook
                vterm-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))
#+end_src

** Parentheses (paren.el / rainbow-delimiters.el)

Configure the mode that highlights matching delimiters or parentheses.
I consider this of utmost importance when working with languages such as
elisp.

Summary of what these do:

- Activate the mode upon startup.
- Show the matching delimiter/parenthesis if on screen, else show
  nothing.  It is possible to highlight the expression enclosed by the
  delimiters, by using either =mixed= or =expression=.  The latter always
  highlights the entire balanced expression, while the former will only
  do so if the matching delimiter is off screen.
- =show-paren-when-point-in-periphery= lets you highlight parentheses even
  if the point is in their vicinity.  This means the beginning or end of
  the line, with space in between.  I used that for a long while and it
  server me well.  Now that I have a better understanding of Elisp, I
  disable it.
- Do not highlight a match when the point is on the inside of the
  parenthesis.
- Use rainbow color for delimiters

#+begin_src emacs-lisp
(use-package paren
  :config
  (setq show-paren-style 'parenthesis)
  (setq show-paren-when-point-in-periphery nil)
  (setq show-paren-when-point-inside-paren nil)
  :hook
  (after-init . show-paren-mode))

(use-package rainbow-delimiters
   :ensure t
  :hook
  (prog-mode . rainbow-delimiters-mode))
#+end_src

** Scrolling behaviour

By default, page scrolling should keep the point at the same visual
position, rather than force it to the top or bottom of the viewport.
This eliminates the friction of guessing where the point has warped to.

As for per-line scrolling, I dislike the default behaviour of visually
re-centring the point: it is too aggressive as a standard mode of
interaction.  With the following =setq-default=, the point will stay at
the top/bottom of the screen while moving in that direction (use =C-l= to
reposition it).

#+begin_src emacs-lisp
(setq-default scroll-preserve-screen-position t)
(setq-default scroll-conservatively 1) ; affects `scroll-step'
(setq-default auto-window-vscroll nil)
(setq-default scroll-margin 0)
#+end_src

** Keybinding hint (which-key.el)

This library provides hints on the possible tails of a key chord.  So if
you type =C-x r= and wait for =which-key-idle-delay=, a pop-up window will
appear showing you the keys you can use and the actions bound to them.

#+begin_src emacs-lisp
(use-package which-key
   :ensure t
  :init
  (which-key-mode)
  :config
  (setq which-key-idle-delay 0.5))
#+end_src

* Completion framework

The optimal way of using Emacs is through searching and narrowing
selection candidates.  Spend less time worrying about where things are
on the screen and more on how fast you can bring them into focus.  This
is, of course, a matter of realigning priorities, as we still wish to
control every aspect of the interface.

** Minibuffer

#+begin_src emacs-lisp
(use-package minibuffer
  :config
  (setq completion-styles '(partial-completion substring flex orderless))
  (setq completion-category-defaults nil)
  (setq completion-cycle-threshold 3)
  ;; (setq completion-flex-nospace nil)
  ;; (setq completion-pcm-complete-word-inserts-delimiters t)
  ;; (setq completion-pcm-word-delimiters "-_./:| ")
  ;; (setq completion-show-help nil)
  ;; (setq completion-auto-help nil)
  (setq completion-ignore-case t)
  (setq-default case-fold-search t)   ; For general regexp
  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t)

  (setq enable-recursive-minibuffers t)
  (setq read-answer-short t)
  (setq resize-mini-windows t)
  (setq minibuffer-eldef-shorten-default t)

  (setq echo-keystrokes 0.25)           ; from the C source code

  (file-name-shadow-mode 1)
  (minibuffer-depth-indicate-mode 1)
  (minibuffer-electric-default-mode 1)

  (add-hook 'minibuffer-setup-hook (lambda () (keyboard-translate ?\C-i ?\H-z)))
  (add-hook 'minibuffer-exit-hook (lambda () (keyboard-translate ?\C-i ?\C-i)))

  (let ((map minibuffer-local-map))
    (define-key map (kbd "H-z") #'backward-char)
    (define-key map (kbd "C-o") #'forward-char)
    (define-key map (kbd "C-u") #'kill-whole-line)
    (define-key map (kbd "C-w") #'backward-kill-word)))
#+end_src

** Incremental narrowing (selectrum.el)

#+begin_src emacs-lisp
(use-package selectrum
  :ensure t
  :config (selectrum-mode +1))
#+end_src

** Completion style (orderless.el)

#+begin_src emacs-lisp
(use-package orderless
  :ensure t
  :config
  (defun ace/orderless-literal-dispatcher (pattern _index _total)
    "Literal style dispatcher using the equals sign as a prefix."
    (when (string-prefix-p "=" pattern)
      `(orderless-literal . ,(substring pattern 1))))
  (defun ace/orderless-initialism-dispatcher (pattern _index _total)
    "Leading initialism dispatcher using the comma sign prefix."
    (when (string-prefix-p "," pattern)
      `(orderless-strict-leading-initialism . ,(substring pattern 1))))
  (setq orderless-component-separator " +")
  (setq orderless-matching-styles
        '(orderless-prefixes
          orderless-literal
          orderless-strict-leading-initialism
          orderless-regexp
          orderless-flex))
  (setq orderless-style-dispatchers
        '(ace/orderless-literal-dispatcher
          ace/orderless-initialism-dispatcher)))
;; :bind (:map minibuffer-local-completion-map ("SPC" . nil)))
#+end_src

** Completion hint (marginalia.el)

This is a utility jointly developed by Daniel Mendler and Omar Antolín
Camarena that provides annotations to completion candidates.  It is
meant to be framework-agnostic, so it works with Selectrum, Icomplete
vertical, and Embark (since 2020-12-20, the latter has become my choice
for visualising the standard completion framework's output

#+begin_src emacs-lisp
(use-package marginalia
  :ensure t
  :config
  (setq marginalia-annotators
        '(marginalia-annotators-heavy
          marginalia-annotators-light))
  (marginalia-mode))
#+end_src

** Minibuffer commands (consult.el)

#+begin_src emacs-lisp
(use-package consult
   :ensure t
  :config
  (setq consult-line-numbers-widen t)
  (setq completion-in-region-function #'consult-completion-in-region)
  (setq consult-async-min-input 3)
  (setq consult-async-input-debounce 0.5)
  (setq consult-async-input-throttle 0.8)
  (setq consult-narrow-key ">")
  (setq consult-imenu-config
        '((emacs-lisp-mode :toplevel "Functions"
                           :types ((?f "Functions" font-lock-function-name-face)
                                   (?m "Macros"    font-lock-keyword-face)
                                   (?p "Packages"  font-lock-constant-face)
                                   (?t "Types"     font-lock-type-face)
                                   (?v "Variables" font-lock-variable-name-face)))))
  ;; Registers' setup -- From Consult's README
  ;; This gives a consistent display for `consult-register',
  ;; `consult-register-load', `consult-register-store', and the Emacs
  ;; built-ins.
  (setq register-preview-delay 0.2
        register-preview-function #'consult-register-format)
  ;; Tweak the register preview window.
  ;; * Sort the registers
  ;; * Hide the mode line
  ;; * Resize the window, such that the contents fit exactly
  (advice-add #'register-preview :around
              (lambda (fun buffer &optional show-empty)
                (let ((register-alist (seq-sort #'car-less-than-car register-alist)))
                  (funcall fun buffer show-empty))
                (when-let (win (get-buffer-window buffer))
                  (with-selected-window win
                    (setq-local mode-line-format nil)
                    (setq-local window-min-height 1)
                    (fit-window-to-buffer))))))

(use-package ace-consult
  :after consult
  :config
  (setq ace/consult-command-centre-list
        '(consult-line
          consult-mark
          consult-outline
          consult-imenu))
  (setq ace/consult-command-top-list '())
  (ace/consult-set-up-hooks-mode 1)
  ;; make sure `C-i/o' can jump between
  (dolist (cmd '(consult-line
                 consult-outline
                 consult-imenu))
    (evil-add-command-properties cmd :jump t)))
#+end_src

** Minibuffer actions (embark.el)

#+begin_src emacs-lisp
(use-package embark
   :ensure t
  :config
  (setq embark-collect-initial-view-alist
        '((file . list)
          (buffer . list)
          (symbol . list)
          (line . list)
          (xref-location . list)
          (kill-ring . zebra)
          (t . list)))
  (setq embark-quit-after-action t)
  (setq embark-key-action-separator (propertize " · " 'face 'shadow))
  (setq embark-action-indicator
        (let ((act (propertize "Act" 'face 'success)))
          (cons act (concat act " on '%s'"))))
  (setq embark-become-indicator (propertize "Become" 'face 'warning))

  (setq embark-action-indicator
        (lambda (map &optional _target)
          (which-key--show-keymap "Embark" map nil nil 'no-paging)
          #'which-key--hide-popup-ignore-command)
        embark-become-indicator embark-action-indicator)

  (define-key global-map (kbd "C-.") #'embark-act)
  (let ((map minibuffer-local-map))
    (define-key map (kbd "C-.") #'embark-act)
    (define-key map (kbd "C-,") #'embark-become))
  (let ((map embark-collect-mode-map))
    (define-key map (kbd "C-.") #'embark-act))
  (let ((map embark-symbol-map))
    (define-key map (kbd "K") #'describe-keymap)))

(use-package ace-embark
  :after embark
  :config
  (ace/embark-extras-keymaps 1)
  (let ((map embark-collect-mode-map))
    (define-key map (kbd "C-k") #'ace/embark-collection-kill-line)
    (define-key map (kbd "H-n") #'ace/embark-completions-act-next)
    (define-key map (kbd "H-p") #'ace/embark-completions-act-previous)))
#+end_src

** Completion utils (ace-completion.el)

#+begin_src emacs-lisp
(use-package ace-complete
  :bind
  ("C-x d" . ace/complete-word-ispell))
#+end_src

* Window / Buffer / Tab

I believe that Emacs' true power lies in its buffer management rather
than its multiplexing.  The latter becomes inefficient at scale, since
it tries to emulate the limitations of the real world, namely, the
placement of things on a desk.

By leveraging the power of the computer, we can use search methods to
easily reach any item.  There is no need to remain confined to the idea
of a finite space (screen real estate) that needs to be carefully
managed.

That granted, Emacs' multiplexing can be turned into a powerhouse as
well, covering everything from window placement rules, to the recording
of history and layouts, as well as directional or direct window
navigation.

** Window rules

The =display-buffer-alist= is intended as a rule-set for controlling the
display of windows.  The objective is to create a more intuitive
workflow where targeted buffer groups or types are always shown in a
given location, on the premise that predictability improves usability.

For each buffer action in =display-buffer-alist= we can define several
functions for selecting the appropriate window.  These are executed in
sequence, but my usage thus far suggests that a simpler method is just
as effective for my case.

#+begin_src emacs-lisp
(use-package window
  :config
  (setq display-buffer-alist
        `(("\\*\\(Flymake\\|Messages\\|Backtrace\\|Warnings\\|Compile-Log\\)\\*"
           (display-buffer-in-side-window)
           (window-width . 0.35)
           (side . top))
          ("\\*\\(Help\\|Faces\\|Warnings\\|Compile-Log\\|Custom\\)\\*"
           (display-buffer-in-side-window)
           (window-width . 0.35)
           (side . left))
          ("\\*.*\\([^E]eshell\\|shell\\|v?term\\).*"
           (display-buffer-reuse-mode-window display-buffer-pop-up-window)
           (window-width . 0.4)
           (side . right)
           (window-parameters . ((mode-line-format . none))))
          ("\\*\\vc-\\(incoming\\|outgoing\\).*"
           (display-buffer-at-bottom))
          ("\\*\\(Output\\|Register Preview\\).*"
           (display-buffer-at-bottom))))

  (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)

  ;; Disable window close when calling 'keyboard-escape-quit'
  (defadvice keyboard-escape-quit
      (around keyboard-escape-quit-dont-close-windows activate)
    (let ((buffer-quit-function (lambda () ())))
      ad-do-it))

  (add-hook 'help-mode-took #'visual-line-mode)
  (add-hook 'custom-mode-hook #'visual-line-mode))
#+end_src

** Window history (winner-mode.el)

Winner is a built-in tool that keeps a record of buffer and window
layout changes.  It then allows us to move back and forth in the
history of said changes.  I have it enabled by default, while I assign
its two main functions to Super and the right/left arrow keys.

#+begin_src emacs-lisp
(use-package winner
  :config
  (add-hook 'after-init-hook #'winner-mode)
  (let ((map global-map))
    (define-key map (kbd "C-c <left>") #'winner-undo)
    (define-key map (kbd "C-c <right>") #'winner-redo)))
#+end_src

** Window Position (transpose-frame.el)

The =transpose-frame= library defines a set of commands for shifting the
layout of Emacs windows.  Rather than me describing how these work, I
strongly encourage you to read the "Commentary" section in the source
code.  Do it with =M-x find-library transpose-frame=.

#+begin_src emacs-lisp
(use-package transpose-frame
   :ensure t
  :config
  (let ((map global-map))
    (define-key map (kbd "C-s-t") #'flop-frame) ; what I consider "transpose" in this context
    (define-key map (kbd "C-s-r") #'rotate-frame-clockwise)))
#+end_src

** Tabs (ace-tab.el)

Starting with version 27.1, Emacs has built-in support for two distinct
concepts of "tabs":

1. Work spaces that contain windows in any given layout.
2. A list of buffers presented as buttons at the top of the window.

The former, represented by the =tab-bar= library, is best understood as
the equivalent of "virtual desktops", as these are used in most desktop
environments or window managers.

The latter, implemented in =tab-line=, is the same as the tabs you are
used to in web browsers.  Each buffer is assigned to a single tab.
Clicking on the tab takes you to the corresponding buffer.

I do not need the =tab-line= as I find such tabs to be inefficient at
scale.  Finding a buffer through search mechanisms is generally faster:
it does not matter whether you have ten or a hundred buffers on the list
(unless, of course, they all have similar names in which case you are in
trouble either way---do not forget to check my [[#h:06290f9c-491c-45b2-b213-0248f890c83d][Ibuffer settings]]).

On the other hand, the work spaces (=tab-bar=) are very useful for
organising the various applications that are running inside of Emacs.
You can, for example, have your current project on tab (workspace) 1,
your email and news reader on 2, music on 3, and so on.  Of course, this
can also be achieved by using separate frames for each of these, though
I generally prefer working in a single frame (plus you can define a
window configuration or frameset in a register).

For me tabs are useful as groups of buffers in a given window
configuration.  I do not want a persistent bar with buttons that
introduces extra visual clutter.  Switching to tabs is done through
completion, specifically =ace/tab-select-tab-dwim=.

All settings I configure here are meant to work in accordance with this
abstract conception of "tabs are work spaces".  Here are the main key
chords for =tab-bar= (they will all work properly if you keep the mode
active):

| Key     | Description                    |
|---------+--------------------------------|
| C-x t b | Open a buffer in a new tab     |
| C-x t d | Open a directory in a new tab  |
| C-x t f | Open a file in a new tab       |
| C-x t 0 | Close current tab              |
| C-x t 1 | Close all other tabs           |
| C-x t 2 | Open current buffer in new tab |

These are consistent with the standard commands for handling windows and
accessing buffers/files in the "other window" (the =C-x 4 KEY= pattern).
There is also a command for giving a name to the current tab, accessed
via =C-x t r=, though I find I do not use it.

Here my settings, followed by the entirety of =prot-tab.el=.

#+begin_src emacs-lisp
(use-package tab-bar
  :config
  (setq tab-bar-tab-choice "NewTab")
  (setq tab-bar-new-button-show nil)
  (setq tab-bar-close-button-show nil)
  (setq tab-bar-close-last-tab-choice 'tab-bar-mode-disable)
  (setq tab-bar-close-tab-select 'recent)
  (setq tab-bar-new-tab-choice t)
  (setq tab-bar-new-tab-to 'right)
  (setq tab-bar-position nil)
  (setq tab-bar-show nil)
  (setq tab-bar-tab-hints nil)
  (setq tab-bar-tab-name-function 'tab-bar-tab-name-all)
  (tab-bar-mode -1)
  (tab-bar-history-mode -1)
  (let ((map global-map))
    (define-key map (kbd "H-s-<tab>") #'tab-next)
    (define-key map (kbd "H-s-`") #'tab-previous))
  (custom-set-faces
   '(tab-bar ((t (:inherit nil :height 1.1))))
   '(tab-bar-tab ((t (:inherit tab-bar :underline nil :weight bold))))
   '(tab-bar-tab-inactive ((t (:inherit tab-bar :weight normal :height 1.0))))))

(use-package ace-tab
  :config
  (let ((map global-map))
    (define-key map (kbd "C-x t h") #'ace/tab-tab-bar-toggle)
    (define-key map (kbd "C-x t t") #'ace/tab-select-tab-dwim)))
#+end_src


*** Tab-bar tabs in the echo area (tab-bar-echo-area.el)

In the previous section on [[#h:63ad472f-c9c2-40ad-9675-1dc529487788][Tabs for window layouts (and prot-tab.el)]], I
explicitly disable the presentation of the tab bar, even though I still
use its functionality.  This keeps the overall aesthetics minimalist,
which I like.  The problem with such a configuration is that we lose
context: it is no longer possible to determine the number of open tabs
nor understand the position of the current one in the list.

This is where Fritz Grabo's =tab-bar-echo-area.el= enters the fray: it
prints a message in the echo area showing the tab list, while it
highlights the current item.  So we can retain both our minimalism and
the contextuality a bar offers.  Simple, yet super effective!

#+begin_src emacs-lisp
(use-package tab-bar-echo-area
   :ensure t
  :config
  (tab-bar-echo-area-mode 1))
#+end_src

** Unique names for buffers

These settings make it easier to work with multiple buffers.  When two
buffers have the same name, Emacs will try to disambiguate them by
displaying their element of differentiation in accordance with the style
of =uniquify-buffer-name-style=.  While =uniquify-strip-common-suffix= will
remove the part of the file system path they have in common.

All such operations are reversed once an offending buffer is removed
from the list, allowing Emacs to revert to the standard of displaying
only the buffer's name.

#+begin_src emacs-lisp
(use-package uniquify
      :config
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-strip-common-suffix t)
  (setq uniquify-after-kill-buffer-p t))
#+end_src

** Ibuffer and extras (ace-ibuffer)

=ibuffer.el= ships with Emacs and it provides a drop-in replacement for
=list-buffers=.  Compared to its counterpart, it allows for granular
control over the buffer list and is more powerful overall.

Overview of its features:

- mark and delete buffers same way you do in =dired= (see the previous
  sections on [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][dired (directory editor, file manager)]]);
- mark by a predicate, such as name, major mode, etc.;
- sort buffers by name, filesystem path, major mode, size;
- run =occur= on the marked buffers (remember: Occur produces a buffer
  that you can edit once you enable the editable state with =e=);
- run =query-replace= or =query-replace-regexp= on marked buffers.

Run the universal help command for major mode documentation (=C-h m=)
while inside =ibuffer= to get a detailed list of all available commands
and their key bindings.

With regard to the following package configurations, these are my tweaks
to the default behaviour and presentation:

+ Prompt for confirmation only when deleting a modified buffer.
+ Hide the summary.
+ Do not open on the other window; use the current one.
+ Do not show empty filter groups.
+ Do not cycle movements.  So do not go to the top when moving downward
  at the last item on the list.

Also watch my [[https://protesilaos.com/codelog/2020-04-02-emacs-intro-ibuffer/][introduction to Ibuffer]] (2020-04-02).

Now some extras that I introduced after I published that video, which
pertain to my =ace-ibuffer.el= library (copied in its entirety below the
package configurations):

+ =ace/ibuffer-buffers-major-mode= produces a filtered list of buffers
  that match the major mode of the current buffer and lets you pick one
  using minibuffer completion.  With an optional prefix argument (=C-u=)
  it places the results in an Ibuffer list.

+ =ace/ibuffer-buffers-vc-root= filters the list to items that match the
  current buffer's version-controlled directory.  In practice, this
  fills the same niche as the built-in =project-switch-to-buffer= (for
  Emacs 28+), with the crucial difference that it neither reads from nor
  writes to the list of known projects (also check my configurations for
  [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and ace-project.el)]]).  When called with an
  optional prefix argument, this command puts its matching candidates in
  an Ibuffer view.

For those two I received guidance from Omar Antolín Camarena with regard
to the use of =read-buffer= and the =lambda= passed to it (any errors are my
own).  This method informs other tools that this type of completion
pertains to buffers, so they can adapt accordingly.  See, in particular,
[[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Extended minibuffer actions and more (embark.el and prot-embark.el)]].

#+begin_src emacs-lisp
(use-package ibuffer
  :config
  (setq ibuffer-expert t)
  (setq ibuffer-display-summary nil)
  (setq ibuffer-use-other-window nil)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-movement-cycle nil)
  (setq ibuffer-default-sorting-mode 'filename/process)
  (setq ibuffer-use-header-line t)
  (setq ibuffer-default-shrink-to-minimum-size nil)
  (setq ibuffer-formats
        '((mark modified read-only locked " "
                (name 30 30 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " " filename-and-process)
          (mark " "
                (name 16 -1)
                " " filename)))
  (setq ibuffer-saved-filter-groups nil)
  (setq ibuffer-old-time 48)
  (add-hook 'ibuffer-mode-hook (lambda () (interactive) (hl-line-mode) (ibuffer-update 0)))
  (let ((map ibuffer-mode-map))
    (define-key map (kbd "* f") #'ibuffer-mark-by-file-name-regexp)
    (define-key map (kbd "* g") #'ibuffer-mark-by-content-regexp) ; "g" is for "grep"
    (define-key map (kbd "* n") #'ibuffer-mark-by-name-regexp)
    (define-key map (kbd "s n") #'ibuffer-do-sort-by-alphabetic)  ; "sort name" mnemonic
    (define-key map (kbd "/ g") #'ibuffer-filter-by-content)))

(use-package ace-ibuffer
  :config
  (let ((map global-map))
    (define-key map (kbd "M-s b") #'ace/ibuffer-buffers-major-mode)
    (define-key map (kbd "M-s r") #'ace/ibuffer-buffers-vc-root)))
#+end_src

** Scratch buffers (scratch.el)
This package will produce a buffer that matches the major mode of the
one you are currently in.  Use it with =M-x scratch=.  Doing that with a
prefix argument (=C-u=) will prompt for a major mode instead.  Simple yet
super effective!

The =prot/scratch-buffer-setup= simply adds some text in the buffer and
renames it appropriately for the sake of easier discovery.  I got the
idea of copying the region from [[https://gist.github.com/eev2/52edbfdb645e26aefec19226c0ca7ad0][a snippet shared by eev2 on GitHub]].

#+begin_src emacs-lisp
(use-package scratch
  :ensure t
  :config
  ;; TODO 2021-01-19: refine `ace/scratch-buffer-setup'
  (defun ace/scratch-buffer-setup ()
    "Add contents to `scratch' buffer and name it accordingly.
If region is active, add its contents to the new buffer."
    (let* ((mode major-mode)
           (string (format "Scratch buffer for: %s\n\n" mode))
           (region (with-current-buffer (current-buffer)
                     (if (region-active-p)
                         (buffer-substring-no-properties
                          (region-beginning)
                          (region-end)))
                     ""))
           (text (concat string region)))
      (when scratch-buffer
	      (save-excursion
          (insert text)
          (goto-char (point-min))
          (comment-region (point-at-bol) (point-at-eol)))
	      (forward-line 2))
      (rename-buffer (format "*Scratch for %s*" mode) t)))
  (add-hook 'scratch-create-buffer-hook #'ace/scratch-buffer-setup)
  (define-key global-map (kbd "C-c s") #'scratch))
#+end_src

* Development

Packages or custom functions for development.

** Major mode

#+begin_src emacs-lisp
(use-package lua-mode
  :ensure t)

(use-package web-mode
  :ensure t
  :config
  (define-derived-mode ace/vue-mode web-mode "ace/vue"
    "A major mode derived from web-mode, for editing .vue files with LSP support.")
  :hook
  (web-mode . (lambda ()
                (setq web-mode-markup-indent-offset 2)
                (setq web-mode-script-padding 0)))
  :mode ("\\.vue\\'" . ace/vue-mode))
#+end_src

** Language server protocol (lsp-mode.el)

#+begin_src emacs-lisp
(use-package lsp-mode
  :ensure t
  :config
  (lsp-register-custom-settings '(("vetur.ignoreProjectWarning" t t)))

  (dolist (dir '("[/\\\\]\\.cache" "[/\\\\]elpa$"))
    (push dir lsp-file-watch-ignored-directories))
  (dolist (hook '(
                  sh-mode-hook
                  lua-mode-hook
                  haskell-mode-hook
                  web-mode-hook
                  typescript-mode-hook
                  ))
    (add-hook hook #'lsp-deferred))
  (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
  (setq lsp-enable-which-key-integration t))

(use-package lsp-tailwindcss
  :ensure t)

(use-package lsp-ui
  :ensure t
  :config

  (setq lsp-ui-sideline-show-code-actions nil)
  (setq lsp-ui-doc-position 'bottom)
       :hook
       (lsp-mode . lsp-ui-mode))

(use-package lsp-treemacs
  :ensure t)
#+end_src

** Auto completion (company-mode.el)

#+begin_src emacs-lisp
(use-package company
  :ensure t
  :hook
  (after-init . global-company-mode)
  :config
  (setq company-idle-delay 0.0)
  (let ((map company-active-map))
    (define-key map (kbd "<tab>") #'company-complete-selection)
    (define-key map (kbd "C-p") #'company-select-previous)
    (define-key map (kbd "C-n") #'company-select-next))
  (setq company-idle-delay 0.0)
  (let ((map company-active-map))
    (define-key map (kbd "<tab>") #'company-complete-selection)
    (define-key map (kbd "C-p") #'company-select-previous)
    (define-key map (kbd "C-n") #'company-select-next)))
#+end_src

** Flycheck

#+begin_src emacs-lisp
;; (use-package flymake
;;   :config
;;   (setq flymake-fringe-indicator-position 'left-fringe)
;;   (setq flymake-suppress-zero-counters t)
;;   (setq flymake-start-on-flymake-mode t)
;;   (setq flymake-no-changes-timeout nil)
;;   (setq flymake-start-on-save-buffer t)
;;   (setq flymake-proc-compilation-prevents-syntax-check t)
;;   (setq flymake-wrap-around nil)
;;   (let ((map flymake-mode-map))
;;     (define-key map (kbd "C-c ! s") #'flymake-start)
;;     (define-key map (kbd "C-c ! d") #'flymake-show-diagnostics-buffer)
;;     (define-key map (kbd "C-c ! n") #'flymake-goto-next-error)
;;     (define-key map (kbd "C-c ! p") #'flymake-goto-prev-error)))

;; (use-package flymake-diagnostic-at-point
;;   :ensure t
;;   :config
;; 	(setq flymake-diagnostic-at-point-display-diagnostic-function
;; 			  'flymake-diagnostic-at-point-display-minibuffer))
#+end_src

** Comment (evil-nerd-commenter.el)

Emacs' built in commenting functionality =comment-dwim= (usually bound to =M-;=) doesn't always comment things in the way you might expect so we use [[https://github.com/redguardtoo/evil-nerd-commenter][evil-nerd-commenter]] to provide a more familiar behavior.  I've bound it to =s-/= since other editors sometimes use this binding but you could also replace Emacs' =M-;= binding with this command.

#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :ensure t)
#+end_src

** Rainbow-mode

#+begin_src emacs-lisp
(use-package rainbow-mode
  :ensure t
  :hook
  (prog-mode . rainbow-mode))
#+end_src

** Formatter (format-all.el)

#+begin_src emacs-lisp
(use-package format-all
  :ensure t)
#+end_src

* Utils
** Dired

#+begin_src emacs-lisp
(use-package dired
  :config
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)
  (setq dired-dwim-target t)
  (setq dired-listing-switches "-AGFhlv --group-directories-first --time-style=long-iso")
  (put 'dired-find-alternate-file 'disabled nil)
  (add-hook 'dired-mode-hook #'dired-hide-details-mode)
  (add-hook 'dired-mode-hook (lambda () (display-line-numbers-mode -1)))
  (add-hook 'dired-mode-hook #'hl-line-mode))

(use-package wdired
  :config
  (setq wdired-allow-to-change-permissions t)
  (setq wdired-create-parent-directories t))

(use-package dired-async
  :hook
  (dired-mode . dired-async-mode))

(use-package ace-dired
  :bind
  (:map evil-normal-state-map ("-" . ranger)))
#+end_src

** EAF

#+begin_src emacs-lisp
(use-package epc)
(use-package deferred)
(use-package eaf
  :config
  ;; (add-hook 'eaf-mode-hook (lambda () (switch-to-buffer-other-window (last-buffer))))
  (setq eaf-browser-continue-where-left-off t)
  (eaf-bind-key nil "M-o" eaf-browser-keybinding)
  ;; (eaf-setq eaf-browse-blank-page-url "https://duckduckgo.com")
  (eaf-setq eaf-browser-enable-adblocker "true")
  (eaf-setq eaf-browser-default-zoom "1.75"))
#+end_src

** Org-mode

#+begin_src emacs-lisp
(defun ace/org-interface-setup()
  (variable-pitch-mode) ;; use different fonts in org-mode buffer
  (org-indent-mode)
  (visual-line-mode)
  (font-lock-add-keywords 'org-mode ;; replace list hyphen with dot
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
  (let* ((variable-tuple
          (cond ((x-list-fonts "Sarasa Mono SC")  '(:font "Sarasa Mono SC"))
                ((x-list-fonts "ETBembo")         '(:font "ETBembo"))
                ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
                ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
                (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
         (base-font-color     (face-foreground 'font-lock-string-face nil 'default))
         (headline           `(:inherit default :weight bold :foreground ,base-font-color)))
    (custom-theme-set-faces 'user
                            `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
                            `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.2))))
                            `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.3))))
                            `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.5))))))
  ;; ensure that anything that should be fixed-pitch in Org files appears that way
  (custom-theme-set-faces 'user
                          '(org-block ((t (:inherit fixed-pitch))))
                          '(org-code ((t (:inherit (shadow fixed-pitch)))))
                          '(org-document-info ((t (:foreground "dark orange"))))
                          '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
                          '(org-indent ((t (:inherit (org-hide fixed-pitch)))))
                          '(org-link ((t (:foreground "royal blue" :underline t))))
                          '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
                          '(org-property-value ((t (:inherit fixed-pitch))) t)
                          '(org-checkbox ((t (:inherit fixed-pitch))) t)
                          '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
                          '(org-table ((t (:inherit fixed-pitch :foreground "#83a598"))))
                          '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
                          '(org-verbatim ((t (:inherit (shadow fixed-pitch)))))))

(use-package org
  :hook
  (org-mode . ace/org-interface-setup)
  (org-tab-first . org-end-of-line)
  :config
  (setq org-adapt-indentation nil)
  (setq org-hide-leading-stars t)
  (setq org-startup-folded t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-edit-src-content-indentation 0)
  (setq org-ellipsis " ▾")
  (setq org-hide-emphasis-markers t)
  (setq org-agenda-start-with-log-mode t)
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  :bind
  (:map org-mode-map
        ("C-'" . org-edit-special)
        ("C-o" . forward-char)
        ("<C-return>" . l)
        ("<C-S-return>" . l)
        ("C-c S-l" . org-toggle-link-display)
        ("C-c C-S-l" . org-insert-last-stored-link)
        :map org-src-mode-map
        ("C-'" . org-edit-src-exit)))

;; Heading bullets
(use-package org-superstar
  :ensure t
  :config
  (setq org-superstar-remove-leading-stars t)
  (setq org-superstar-headline-bullets-list '("◉" "○" "●" "○" "●" "○" "●"))
  :hook
  (org-mode . org-superstar-mode))

;; Center Org Buffers
(use-package visual-fill-column
  :ensure t
  :config
  (defun ace/org-mode-visual-fill ()
    (setq visual-fill-column-width 120
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))
  :hook
  (org-mode . ace/org-mode-visual-fill))

;; org-habit
(use-package org-habit
  :config
  (add-to-list 'org-modules 'org-habit)
  (setq org-habit-graph-column 60))

;; org-babel
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python . t)
   (haskell . t)))
(push '("conf-unix" . conf-unix) org-src-lang-modes)

;; org-tempo
(use-package org-tempo ; this is needed as of Org 9.2
  :config
  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("hk" . "src haskell"))
  (add-to-list 'org-structure-template-alist '("py" . "src python")))
#+end_src

** Vterm

#+begin_src emacs-lisp
(use-package vterm
  :ensure t
  :config
  (setq vterm-always-compile-module t)
  (defun ace/vterm-send-key (key &optional shift meta ctrl)
    "Send KEY to libvterm with optional modifiers SHIFT, META and CTRL."
    (deactivate-mark)
    (when vterm--term
      (let ((inhibit-redisplay t)
            (inhibit-read-only t))
        (when (and (not (symbolp last-input-event)) shift (not meta) (not ctrl))
          (setq key (upcase key)))
        (vterm--update vterm--term key shift meta ctrl)
        (setq vterm--redraw-immididately t)
        (when (not (eq evil-state 'insert))
          (accept-process-output vterm--process vterm-timer-delay nil t)))))
  (defun ace/vterm-hook ()
    (evil-define-key 'insert 'local [escape] #'vterm-send-escape)
    (evil-define-key 'insert 'local (kbd "<C-return>") '(lambda () (interactive) (vterm-send-key "<f5>")))
    (evil-define-key 'insert 'local (kbd "C-i") '(lambda () (interactive) (vterm-send-key "<f6>")))
    (set (make-local-variable 'buffer-face-mode-face) 'fixed-pitch)
    (vterm-reset-cursor-point)
    (buffer-face-mode t))
  (advice-add 'vterm-send-key :override #'ace/vterm-send-key)
  :hook
  (vterm-mode . ace/vterm-hook))
#+end_src

** Version control (magit.el)

#+begin_src emacs-lisp
(use-package magit
  :ensure t
  :config
  (setq magit-define-global-key-bindings nil)
  (define-key magit-mode-map (kbd "`") #'magit-diff-show-or-scroll-up)
  (define-key magit-diff-mode-map (kbd "`") #'scroll-up)
  (define-key global-map (kbd "C-c g") #'magit-status)

  (require 'git-commit)
  (setq git-commit-summary-max-length 50)
  (setq git-commit-known-pseudo-headers
        '("Signed-off-by"
          "Acked-by"
          "Modified-by"
          "Cc"
          "Suggested-by"
          "Reported-by"
          "Tested-by"
          "Reviewed-by"))
  (setq git-commit-style-convention-checks
        '(non-empty-second-line
          overlong-summary-line))

  (require 'magit-diff)
  (define-key magit-diff-section-base-map (kbd "<C-return>") #'magit-diff-visit-file-other-window)
  (setq magit-diff-refine-hunk t)

  (require 'magit-repos)
  (setq magit-repository-directories
        '(("~/Dev" . 1))))

(use-package git-gutter
  :ensure t
  :config
  (custom-set-variables
   '(git-gutter:modified-sign "⏽")
   '(git-gutter:added-sign "⏽")
   '(git-gutter:deleted-sign "⏽"))
  (global-git-gutter-mode +1))

(use-package ediff
  :config
  (setq ediff-keep-variants nil)
  (setq ediff-make-buffers-readonly-at-startup nil)
  (setq ediff-merge-revisions-with-ancestor t)
  (setq ediff-show-clashes-only t)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; Tweak those for safer identification and removal
  (setq ediff-combination-pattern
        '("<<<<<<< ace-ediff-combine Variant A" A
          ">>>>>>> ace-ediff-combine Variant B" B
          "####### ace-ediff-combine Ancestor" Ancestor
          "======= ace-ediff-combine End"))

  (defun ace/ediff-flush-combination-pattern ()
    "Remove my custom `ediff-combination-pattern' markers.

This is a quick-and-dirty way to get rid of the markers that are
left behind by `smerge-ediff' when combining the output of two
diffs.  While this could be automated via a hook, I am not yet
sure this is a good approach."
    (interactive)
    (flush-lines ".*ace-ediff.*" (point-min) (point-max) nil)))
;; (use-package forge)
#+end_src

** Project management (project.el)

#+begin_src emacs-lisp
(use-package project
  :config
  (setq project-switch-commands
        '((?f "File" project-find-file)
          (?s "Subdir" ace/project-find-subdir)
          (?g "Grep" project-find-regexp)
          (?d "Dired" project-dired)
          (?b "Buffer" project-switch-to-buffer)
          (?q "Query replace" project-query-replace-regexp)
          (?t "Tag switch" ace/project-retrieve-tag)
          (?m "Magit" ace/project-magit-status)
          (?l "Log VC" ace/project-commit-log)
          (?e "Eshell" project-eshell)))
  :bind-keymap
  ("H-." . project-prefix-map))

(use-package ace-project
  :config
  (setq ace/project-project-roots '("~/Dev/" "~/"))
  (setq ace/project-commit-log-limit 25)
  (setq ace/project-large-file-lines 1000)
  (let ((map global-map))
    (define-key map (kbd "C-x p DEL") #'ace/project-remove-project)
    (define-key map (kbd "C-x p l") #'ace/project-commit-log)
    (define-key map (kbd "C-x p m") #'ace/project-magit-status)
    (define-key map (kbd "C-x p s") #'ace/project-find-subdir)
    (define-key map (kbd "C-x p t") #'ace/project-retrieve-tag)))
#+end_src

** Trash (trashed.el)

=trashed= applies the principles of =dired= to the management of the user's
filesystem trash.  Use =C-h m= to see the docs and keybindings for its
major mode.

Basically, its interaction model is as follows:

- =m= to mark for some deferred action, such as =D= to delete, =R= to restore.
- =t= to toggle the status of all items as marked.  Use this without marks
  to =m= (mark) all items, then call a deferred action to operate on them.
- =d= to mark for permanent deletion.
- =r= to mark for restoration.
- =x= to execute these special marks.

#+begin_src emacs-lisp
(use-package trashed
  :ensure t
  :config
  (setq trashed-action-confirmer 'y-or-n-p)
  (setq trashed-use-header-line t)
  (setq trashed-sort-key '("Date deleted" . t))
  (setq trashed-date-format "%Y-%m-%d %H:%M:%S"))
#+end_src

* Keybinding

This section is for my finalized global keybinds which contains super key
combination and leader key in various modes. To ensure other config has been
fully loaded, I put this section at the end of my config file.

** Key fix

For historical reason, terminal can not tell the difference between some key
storkes. For example, =C-i= and =Tab=, =C-m= and =Return=, etc. By default, emacs follow
this convention, but it doesn't mean emacs are not able to tell the
difference. To change this behaviour, we can use =input-decode-map= to give, for
example, =C-m= different meaning.

#+begin_src emacs-lisp
(defun ace/key-fix (&optional frame)
  "To distinguish C-m from RET."
  (with-selected-frame (or frame (selected-frame))
    (when window-system
      (define-key input-decode-map [?\C-m] [C-m]))))
;; (ace/key-fix)
(add-hook 'after-make-frame-functions #'ace/key-fix)

(define-key global-map (kbd "<C-m>") #'call-last-kbd-macro)
#+end_src

** Super key

#+begin_src emacs-lisp
(let ((map global-map))
  (define-key map (kbd "s-/") #'evilnc-comment-or-uncomment-lines)
  (define-key map (kbd "s-[") #'winner-redo)
  (define-key map (kbd "s-]") #'winner-undo)
  (define-key map (kbd "s-=") #'balance-windows-area)
  (define-key map (kbd "s-a") #'ibuffer)
  (define-key map (kbd "s-f") #'ace/ibuffer-buffers-major-mode)
  (define-key map (kbd "s-l") #'consult-line)
  (define-key map (kbd "s-i") #'next-buffer)
  (define-key map (kbd "s-m") #'ace/simple-monocle)
  (define-key map (kbd "s-o") #'previous-buffer)
  (define-key map (kbd "s-v") #'split-window-right)
  (define-key map (kbd "s-w") #'save-buffer)
  (define-key map (kbd "s-z") #'window-toggle-side-windows))
#+end_src

** Leader key (transient.el)

I believe transient provides a better interface for complex (usually with
prefix) keybindings. This package is actually a part of =magit=, serve as the key
chords interface. For example, you type =c= in magit, it will give you a menu
window with a lot of hints about what command/action you might want to execute
next. Comparing to =which-key=, which is a similar project, it has better
classification of commands and better UI overall.

#+begin_src emacs-lisp
(use-package transient
  :ensure t
  :bind
  (:map transient-map ("<escape>" . transient-quit-all))
  :custom
  (transient-show-popup -0.5)
  :config
  (transient-bind-q-to-quit)
  (transient-define-prefix ace/transient-evil-leader ()
    "Evil leader keybind"
    ["Shortcuts"
     [("SPC" "Find file in project" project-find-file)
      ("fo" "Find file other window" ace/project-fd-other-window)
      ("ff" "Format file" format-all-buffer)
      ("fr" "Rename file" ace/simple-rename-file-and-buffer)
      ("fw" "Write file" save-buffer)
      ("f." "Edit emacs config" (lambda () (interactive) (find-file ace/init-org-path)))]
     [("ee" "Eval last s-expression" eval-last-sexp)
      ("ex" "Eval expression" eval-expression)
      ("ef" "Eval defun" eval-defun)
      ("eb" "Eval buffer" eval-buffer)
      ("er" "Elisp repl" ielm)]
     [("tn" "New/Select tab" ace/tab-select-tab-dwim)
      ("tx" "Close tab" tab-close)
      ("tt" "Toggle tab line" ace/tab-tab-bar-toggle)]
     [("gg" "Open magit client" magit-status)]]
    ["Search"
     [("rg" "Grep" consult-grep)
      ("rr" "Rg menu" rg-menu)
      ("rf" "Rg on file" rg-dwim-current-file)
      ("rp" "Rg on project" ace/rg-project-dwim)]
     [("lk" "Keep lines" consult-keep-lines)
      ("lf" "Focus lines" consult-focus-lines)
      ("lm" "Marks" consult-mark)]
     [("si" "Imenu" consult-imenu)
      ("so" "Outline" consult-outline)
      ("sr" "Register" consult-register)
      ("sy" "Cycle kill-ring" consult-yank)]
     [("mm" "Minor mode menu" consult-minor-mode-menu)
      ("mM" "Mode menu" consult-mode-command)
      ("mc" "Complex commands" consult-complex-command)
      ("mv" "Buffer in current project" ace/ibuffer-buffers-vc-root)]]
    ["Launcher"
     [("ot" "Open vterm" vterm)
      ("op" "Open/Switch project" project-switch-project)]])
  (dolist (map (list evil-normal-state-map
                     magit-mode-map
                     dired-mode-map))
    (define-key map (kbd "SPC") #'ace/transient-evil-leader)))
#+end_src

