#+TITLE: Emacs Configuration
#+AUTHOR: Alex Lu
#+EMAIL: alexluigit@gmail.com

* Overview

My Emacs configuration file written in org format.

** Init

'init' and 'early-init'

* Basic

** Custom utils library

There are a few utilities that I keep re-using in various parts of my Emacs code base. To keep things modular, I place them all in a dedicated =ace-atom.el= file, which can then be marked as a dependency by other libraries of mine. As such, all we here is load the file.

#+begin_src emacs-lisp
(ace/builtin-package 'ace-atom)
#+end_src

** Disable emacs auto appending to init.el

When you install a package or use the various customisation interfaces to tweak things to your liking, Emacs will append a piece of Elisp to your init file. In my experience, this is a common source of inconsistencies, arising from a conflict between the user's code and what is stored in that custom snippet.

As it does not seem possible to outright disable this behaviour, I instruct Emacs to place all "custom" code in a temporary file that never gets loaded. This feels kinda hacky but is better than having some arbitrary code that you accidentally evaluated from messing up with your carefully designed (and version-controlled) configuration.

#+begin_src emacs-lisp
(ace/builtin-package 'cus-edit
  ;; Disable the damn thing
  (setq custom-file (make-temp-file "emacs-custom-")))
#+end_src

** Backups

#+begin_src emacs-lisp
(setq make-backup-files nil)
(setq auto-save-list-file-prefix nil)
#+end_src

** History/State

This section contains configurations for packages that are dedicated to
the task of recording the state of various Emacs tools, such as the
history of the minibuffer or the list of recently visited files.

In practice, these are some of the most useful configurations one can
make, as lots of functions depend on them. For example, a record of the
minibuffer's history of inputs allows the completion framework to guess
the most likely course of action. Typing =M-x g= gives me =gnus= as the
first possible option, which is exactly what I want.

** Async facilities

This package provides some asynchronous processing facilities for
various Emacs interfaces, such as for Dired's copy and rename operations
(also read [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][Dired (directory editor, file manager)]]).

#+begin_src emacs-lisp
(ace/elpa-package 'async)
#+end_src

** Simiple
=ace-simple.el= contains a wide range of commands that are broadly in line with the built-in =simple.el= and =lisp.el= libraries.

#+begin_src emacs-lisp
(ace/builtin-package 'ace-simple
  (setq ace/simple-date-specifier "%F")
  (setq ace/simple-time-specifier "%R %z")
  ;; To distinguish C-m from RET
  (define-key input-decode-map [?\C-m] [C-m]);
  ;; Global mappings
  (let ((map global-map))
    ;; (define-key map (kbd "C-=") #'ace/simple-insert-date)
    ;; (define-key map (kbd "C-<") #'ace/simple-escape-url)
    ;; (define-key map (kbd "M-Q") #'ace/simple-unfill-region-or-paragraph)
    (define-key map (kbd "<C-m>") #'call-last-kbd-macro);
    (define-key map (kbd "M-=") #'count-words)
    (define-key map (kbd "C-h K") #'describe-keymap)
    (define-key map (kbd "<escape>") #'keyboard-escape-quit)))
#+end_src

* Text Editing

For text editing, I use =evil= mode, which stand for 'emacs vim emulation layer'
or something like that.

** Evil

#+begin_src emacs-lisp
(setq evil-want-integration nil)
(setq evil-want-keybinding nil)
(setq evil-want-Y-yank-to-eol t)
(setq evil-want-C-u-scroll t)
(setq evil-want-C-i-jump t)

(ace/elpa-package 'evil
  (evil-mode)
  (setq evil-echo-state nil)                  ;; We have state (normal/insert/etc.) in modeline
  (setq evil-regexp-search t)                 ;; Use regex when search with '/' and '?'
  (setq-default evil-jumps-cross-buffers nil) ;; Don't jump to other buffer
  (custom-set-variables '(evil-undo-system 'undo-redo))
  (evil-set-initial-state 'messages-buffer-mode 'normal)
  (evil-set-initial-state 'dired-mode 'emacs)
  (evil-set-initial-state 'vterm-mode 'emacs)
  (evil-set-initial-state 'eaf-mode 'emacs)
  (evil-set-initial-state 'dashboard-mode 'normal))

(with-eval-after-load 'evil
  (ace/builtin-package 'ace-evil
    (setq ace/evil-visualstar-persistent nil)
    (ace/global-evil-visualstar-mode)
    (evil-global-set-key 'motion "n"           #'evil-next-visual-line)
    (evil-global-set-key 'normal "N"           #'evil-join)
    (evil-global-set-key 'normal "p"           #'evil-previous-visual-line)
    (evil-global-set-key 'normal "P"           #'helpful-at-point)
    (evil-global-set-key 'normal "k"           #'evil-paste-after)
    (evil-global-set-key 'normal "K"           #'evil-paste-before)
    (evil-global-set-key 'normal "U"           #'evil-redo)
    (evil-global-set-key 'normal "-"           #'dired-jump)
    (evil-global-set-key 'normal (kbd "<tab>") #'ace/evil-tab)
    (evil-global-set-key 'normal (kbd "C-.")   nil)
    (evil-global-set-key 'normal (kbd "C-n")   #'evil-search-next)
    (evil-global-set-key 'normal (kbd "C-p")   #'evil-search-previous)))

(ace/elpa-package 'evil-collection
  (evil-collection-init '(vterm helpful help)))

(ace/elpa-package 'evil-surround (global-evil-surround-mode 1))
#+end_src

** Paragraphs and fill-mode (ace-fill.el)

The =ace-fill.el= library (reproduced below) is a tiny wrapper around
some Emacs settings and modes that are scrattered around several files,
which control (i) how paragraphs or comments in programming modes should
be wrapped to a given column count, and (ii) what constitutes a
sentence.  I put them all together here to make things easier to track.

+ With regard to paragraphs, I find that a double space is the best way
  to delimit sentences in source form, where a monospaced typeface is
  customary.  There is no worry that this will be shown on a website or
  rendered version of a document, because processors know how to handle
  spacing.  We do this to make phrases easier to tell apart, but also to
  render unambiguous commands like =forward-sentence=.

+ =prot-fill-fill-mode= sets my desired default column width for all
  buffers, while it applies another value for programming modes (in case
  there is a need to control the two cases separately).  Those values
  are stored in the variables =prot-fill-default-column= and
  =prot-fill-prog-mode-column= respectively.  My minor mode also enables
  =auto-fill-mode= in =text-mode= and =prog-mode= buffers through the
  appropriate hooks.  Disabling =prot-fill-fill-mode= will remove all
  those customisations.

Note that [[#h:ae48fe61-a3c3-4132-8986-785f9bfbeafb][Common custom functions (prot-simple.el)]] contains some
commands related to auto-fill.  Besides, you can always do it manually
for the current paragraph or the active region with =M-x fill-paragraph=,
bound by default to =M-q=.

#+begin_src emacs-lisp
(ace/builtin-package 'ace-fill
 (setq ace/fill-default-column 80)
 (setq ace/fill-prog-mode-column 100)  ; Set this to another value if you want
 ;; Those variables come from various sources, though they feel part of the
 ;; same conceptual framework.
 (setq sentence-end-double-space t)
 (setq sentence-end-without-period nil)
 (setq colon-double-space nil)
 (setq use-hard-newlines nil)
 (setq adaptive-fill-mode t)
 (ace/fill-fill-mode 1))
#+end_src

** Electric

Emacs labels as "electric" any behaviour that involves contextual
auto-insertion of characters.  This is a summary of my settings:

+ Indent automatically.
+ If =electric-pair-mode= is enabled (which I might do manually), insert
  quotes and brackets in pairs.  Only do so if there is no alphabetic
  character after the cursor.
+ The cryptic numbers in the pairs set, correspond to curly single and
  double quotes and these =«»=.  The contents of this set are always
  inserted in pairs, regardless of major mode.
  + To get those numbers, evaluate =(string-to-char CHAR)= where CHAR is
    the one you are interested in.  For example, get the literal tab's
    character with =(string-to-char "\t")=.
+ While inputting a pair, inserting the closing character will just skip
  over the existing one, rather than add a new one.  So typing =(= will
  insert =()= and then typing =)= will just be the same as moving forward
  one character =C-f=.
+ Do not skip over whitespace when operating on pairs.  Combined with
  the above point, this means that a new character will be inserted,
  rather than be skipped over.  I find this better, because it prevents
  the point from jumping forward, plus it allows for more natural
  editing.
+ The whitespace characters are space (=\s=), tab (=\t=), and newline (=\n=).
+ The rest concern the conditions for transforming quotes into their
  curly equivalents.  I keep this disabled, because curly quotes are
  distinct characters.  It is difficult to search for them.  Just note
  that on GNU/Linux you can type them directly by hitting the "compose"
  key and then an angled bracket (=<= or =>=) followed by a quote mark.

#+begin_src emacs-lisp
(ace/builtin-package 'electric
  (setq electric-pair-inhibit-predicate'electric-pair-conservative-inhibit)
  (setq electric-pair-preserve-balance t)
  (setq electric-pair-pairs
        '((8216 . 8217)
          (8220 . 8221)
          (171 . 187)))
  (setq electric-pair-skip-self 'electric-pair-default-skip-self)
  (setq electric-pair-skip-whitespace nil)
  (setq electric-pair-skip-whitespace-chars '(9 10 32))
  (setq electric-quote-context-sensitive t)
  (setq electric-quote-paragraph t)
  (setq electric-quote-string nil)
  (setq electric-quote-replace-double t)
  (electric-indent-mode 1)
  (electric-pair-mode 1)
  (electric-quote-mode -1))
#+end_src

** Tabs/indentation/TAB key

I believe tabs, in the sense of inserting the tab character, are best
suited for indentation.  While spaces are superior at precisely aligning
text.  However, I understand that elisp uses its own approach, which I
do not want to interfere with.  Also, Emacs tends to perform alignments
by mixing tabs with spaces, which /can actually lead to misalignments/
depending on certain variables such as the size of the tab.  As such, I
am disabling tabs by default.

If there ever is a need to use different settings in other modes, we can
customise them via hooks.  This is not an issue I have encountered yet
and am therefore refraining from solving a problem that does not affect
me.

Note that =tab-always-indent= will first do indentation and then try to
complete whatever you have typed in.

#+begin_src emacs-lisp
(setq-default tab-always-indent 'complete)
(setq-default tab-first-completion 'word-or-paren-or-punct) ; Emacs 27
(setq-default tab-width 2)
(setq-default indent-tabs-mode nil)
(setq-default evil-shift-width tab-width)
#+end_src

** Visual
*** Parentheses

Configure the mode that highlights matching delimiters or parentheses.
I consider this of utmost importance when working with languages such as
elisp.

Summary of what these do:

- Activate the mode upon startup.
- Show the matching delimiter/parenthesis if on screen, else show
  nothing.  It is possible to highlight the expression enclosed by the
  delimiters, by using either =mixed= or =expression=.  The latter always
  highlights the entire balanced expression, while the former will only
  do so if the matching delimiter is off screen.
- =show-paren-when-point-in-periphery= lets you highlight parentheses even
  if the point is in their vicinity.  This means the beginning or end of
  the line, with space in between.  I used that for a long while and it
  server me well.  Now that I have a better understanding of Elisp, I
  disable it.
- Do not highlight a match when the point is on the inside of the
  parenthesis.
- Use rainbow color for delimiters

#+begin_src emacs-lisp
(ace/builtin-package 'paren
  (setq show-paren-style 'parenthesis)
  (setq show-paren-when-point-in-periphery nil)
  (setq show-paren-when-point-inside-paren nil)
  (add-hook 'after-init-hook #'show-paren-mode))

(ace/elpa-package 'rainbow-delimiters
  (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+end_src

*** Lines
Disable line truncate.

#+begin_src emacs-lisp
(setq-default truncate-lines nil)
#+end_src

** Search/Replace
*** Isearch/occur/extras (ace-search.el)

The built-in search mechanisms, defined in the libraries =isearch.el= and
=replace.el= are minimal in their presentation, yet powerful in their
applications.  There are the main points of entry to the commands they
offer:

+ =isearch-forward= (=C-s=) prompts for a string after point and offers live
  feedback on its progress.  =isearch-backward= (=C-r=) moves in the
  opposite direction.

  - Two distinct keys may seem redundant at first, but you really
    appreciate this level of precision when recording keyboard macros
    (see, for example, my video about [[https://protesilaos.com/codelog/2020-01-21-emacs-isearch-kmacro/][Isearch powers in keyboard macros]]
    (2020-01-21)).

  - Use =C-M-s= and =C-M-r= for running a search against a regular
    expression, or call =isearch-toggle-regexp= (=M-r=) after starting a
    regular isearch.

+ =query-replace= (=M-%=) replaces all matches of a string and asks you for
  confirmation on each of them.  If you check its help page (press =?=
  after invoking the command), you will learn that =!= stands for an
  affirmative answer to all, which is a standard in all such prompts.

  - =query-replace-regexp= (=C-M-%=) does the same for regular expressions.

+ =occur= (=M-s o=) places all matches of a regular expression or string in
  a dedicated buffer.  That can function as an index for moving to the
  relevant points in the buffer, but also as a means of refactoring all
  matches at once.  Just make the =*Occur*= buffer editable with =o=.
  Running =occur= with a numeric argument provides N lines of context
  around the given match.

#+begin_src emacs-lisp
(ace/builtin-package 'isearch
  (setq search-highlight t)
  (setq search-whitespace-regexp ".*?")
  (setq isearch-lax-whitespace t)
  (setq isearch-regexp-lax-whitespace nil)
  (setq isearch-lazy-highlight t)
  ;; All of the following variables were introduced in Emacs 27.1.
  (setq isearch-lazy-count t)
  (setq lazy-count-prefix-format nil)
  (setq lazy-count-suffix-format " (%s/%s)")
  (setq isearch-yank-on-move 'shift)
  (setq isearch-allow-scroll 'unlimited)
  (define-key minibuffer-local-isearch-map (kbd "M-/") #'isearch-complete-edit)
  (let ((map isearch-mode-map))
    (define-key map (kbd "C-g") #'isearch-cancel) ; instead of `isearch-abort'
    (define-key map (kbd "M-/") #'isearch-complete)))

(ace/builtin-package 'replace
  (setq list-matching-lines-jump-to-current-line t)
  (add-hook 'occur-mode-hook #'hl-line-mode)
  (add-hook 'occur-mode-hook (lambda ()
                               (toggle-truncate-lines t)))
  (define-key global-map (kbd "M-s O") #'multi-occur)
  (define-key occur-mode-map (kbd "t") #'toggle-truncate-lines))

(ace/builtin-package 'ace-search
;;   (let ((map global-map))
;;     (define-key map (kbd "M-s %") #'ace/search-isearch-replace-symbol)
;;     (define-key map (kbd "M-s M-<") #'ace/search-isearch-beginning-of-buffer)
;;     (define-key map (kbd "M-s M->") #'ace/search-isearch-end-of-buffer)
;;     (define-key map (kbd "M-s u") #'ace/search-occur-urls)
;;     (define-key map (kbd "M-s M-u") #'ace/search-occur-browse-url))
  (let ((map isearch-mode-map))
;;     (define-key map (kbd "<up>") #'ace/search-isearch-repeat-backward)
;;     (define-key map (kbd "<down>") #'ace/search-isearch-repeat-forward)
    ;; (define-key map (kbd "<C-return>") #'ace/search-isearch-other-end)
    (define-key map (kbd "<backspace>") #'ace/search-isearch-abort-dwim)))
#+end_src

*** Regular expressions: re-builder and visual-regexp

To learn more about regular expressions, read the relevant pages in
the official manual.  Assuming you have this installed properly on
your system, run =C-h r i regexp= to get to the starting chapter.

Also watch my ~35 minute-long [[https://protesilaos.com/codelog/2020-01-23-emacs-regexp-primer/][primer on Emacs regexp]] (2020-01-23).

Emacs offers a built-in package for practising regular expressions.
By default, =re-builder= uses Emacs-style escape notation, in the form
of double backslashes.  You can switch between the various styles by
using =C-c TAB= inside of the regexp builder's buffer.  I choose to keep
this style as the default.  Other options are =string= and =rx=.

#+begin_src emacs-lisp
(ace/builtin-package 're-builder
  (setq reb-re-syntax 'read))
#+end_src

Another option (though the two are not mutually exclusive) is to use
the third-party package =visual-regexp=.  This one is meant as a drop-in
replacement for =query-replace= (and the regexp variant).  I prefer not
to use it that way, but only invoke it via =M-x= when I need to test a
regular expression that I would then replace with something else.  The
major upside of this tool is that it highlights groups individually
and offers a live preview of the replacement, making it absolutely
great when dealing with complex sets of regexp constructs.

#+begin_src emacs-lisp
(ace/elpa-package 'visual-regexp
  (setq vr/default-replace-preview nil)
  (setq vr/match-separator-use-custom-face t))
#+end_src

*** wgrep (writable grep)

With =wgrep= we can directly edit the results of a =grep= and save the
changes to all affected buffers.  In principle, this is the same as what
the built-in =occur= offers.  We can use it to operate on a list of
matches by leveraging the full power of Emacs' editing capabilities
(e.g. keyboard macros, query and replace a regexp...).

#+begin_src emacs-lisp
(ace/elpa-package 'wgrep
  (setq wgrep-auto-save-buffer t)
  (setq wgrep-change-readonly-file t)
  (let ((map grep-mode-map))
    (define-key map (kbd "o") #'wgrep-change-to-wgrep-mode)
    (define-key map (kbd "C-x C-q") #'wgrep-change-to-wgrep-mode)
    (define-key map (kbd "C-c C-c") #'wgrep-finish-edit)))
#+end_src

*** Cross-references (xref.el)

Xref provides helpful commands for code navigation and discovery, such
as =xref-find-definitions= (=M-.=) and its counterpart =xref-pop-marker-stack=
(=M-,=).  It is a library that gets used by a variety of tools, including
=project.el= (see [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and ace/project.el)]]).

Here are just the basics.  I might add more in the future.

#+begin_src emacs-lisp
(ace/builtin-package 'xref
  ;; All those have been changed for Emacs 28
  (setq xref-show-definitions-function #'xref-show-definitions-completing-read)
  (setq xref-show-xrefs-function #'xref-show-definitions-completing-read)
  (setq xref-file-name-display 'project-relative)
  (setq xref-search-program 'ripgrep))
#+end_src

* Interface/Interaction

General interface section including fontface/icon/etc function
definition.

** Helpful

A better help buffer.

#+begin_src emacs-lisp
(ace/elpa-package 'helpful
  (let ((map global-map))
       (define-key map [remap describe-function] #'helpful-callable)
       (define-key map [remap describe-variable] #'helpful-symbol)
       (define-key map [remap describe-key] #'helpful-key)))
#+end_src

** Frame
*** Fringe-mode

#+begin_src emacs-lisp
(set-fringe-mode 10) ; Give some breathing room
(add-to-list 'default-frame-alist '(internal-border-width . 30))
#+end_src

*** Winow divider

This is a built-in mode that draws vertical window borders in a slightly
different way than the default, which I find more consistent.  Only
using it because of that, though it can also adjust the size of the
borders as well as their placement.

#+begin_src emacs-lisp
(setq window-divider-default-right-width 3)
(setq window-divider-default-bottom-width 3)
(setq window-divider-default-places 'right-only)
(add-hook 'after-init-hook #'window-divider-mode)
#+end_src

** Theme & icons

#+begin_src emacs-lisp
(ace/elpa-package 'doom-themes
		  (load-theme 'doom-dracula t))

(ace/elpa-package 'all-the-icons)
#+end_src

** Doom-modeline

#+begin_src emacs-lisp
(ace/elpa-package 'doom-modeline
  (column-number-mode)
  (setq doom-modeline-height 28)
  (setq doom-modeline-major-mode-icon t)
  (doom-modeline-mode t))
#+end_src

** Fontface

#+begin_src emacs-lisp
(ace/builtin-package 'ace-fonts
  (defun ace/set-font-faces ()
      (ace/font-set en-font-list ace/default-font-size zh-font-list 0.95)
      ;; (set-face-attribute 'default nil :font "Fira Code Retina" :height ace/default-font-size)
      ;; (set-face-attribute 'default nil :font "Iosevka SS04" :height ace/default-font-size)
      (set-face-attribute 'fixed-pitch nil :font "Victor Mono" :height ace/default-font-size)
      (set-face-attribute 'variable-pitch nil :font "Fira Code Retina" :height ace/default-variable-font-size :weight 'regular)
      (custom-set-faces '(font-lock-keyword-face ((t (:slant italic))))))

  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame)
      (setq doom-modeline-icon t)
      (unless (file-exists-p "~/.local/share/fonts/all-the-icons.ttf")
                        (all-the-icons-install-fonts t))
      (with-selected-frame frame (ace/set-font-faces))))
        (ace/set-font-faces)))
#+end_src

** Line Number

#+begin_src emacs-lisp
(global-display-line-numbers-mode t)
(dolist (mode '(org-mode-hook
                term-mode-hook
                shell-mode-hook
                treemacs-mode-hook
                eshell-mode-hook
                vterm-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))
#+end_src

** Scrolling behaviour

By default, page scrolling should keep the point at the same visual
position, rather than force it to the top or bottom of the viewport.
This eliminates the friction of guessing where the point has warped to.

As for per-line scrolling, I dislike the default behaviour of visually
re-centring the point: it is too aggressive as a standard mode of
interaction.  With the following =setq-default=, the point will stay at
the top/bottom of the screen while moving in that direction (use =C-l= to
reposition it).

#+begin_src emacs-lisp
(setq-default scroll-preserve-screen-position t)
(setq-default scroll-conservatively 1) ; affects `scroll-step'
(setq-default auto-window-vscroll nil)
(setq-default scroll-margin 0)
#+end_src

** Pulse highlight changes (evil-goggles.el)

This is another package by Daniel Mendler which pulses the area where
some change took effect.  It is a subtle, yet effective, method to
visually capture the affected region of text and, thus, be confident
that no mistakes were made in the process (or notice those as they
occur).

#+begin_src emacs-lisp
(ace/elpa-package 'evil-goggles
  (evil-goggles-mode))
#+end_src

** Which-key

This library provides hints on the possible tails of a key chord.  So if
you type =C-x r= and wait for =which-key-idle-delay=, a pop-up window will
appear showing you the keys you can use and the actions bound to them.

#+begin_src emacs-lisp
(ace/elpa-package 'which-key
  (setq which-key-idle-delay 0.5)
  (which-key-mode))
#+end_src

* Completion framework

The optimal way of using Emacs is through searching and narrowing
selection candidates.  Spend less time worrying about where things are
on the screen and more on how fast you can bring them into focus.  This
is, of course, a matter of realigning priorities, as we still wish to
control every aspect of the interface.

** Selectrum (incremental narrowing)

#+begin_src emacs-lisp
(defun refresh-selectrum ()
  (setq selectrum--previous-input-string nil))
(ace/elpa-package 'selectrum
  (selectrum-mode +1)
  ;; (add-hook 'embark-pre-action-hook #'refresh-selectrum)
  (setq selectrum-fix-vertical-window-height 20))
#+end_src

** Orderless completion style

#+begin_src emacs-lisp
(ace/builtin-package 'ace-orderless
  (setq ace/orderless-default-styles
        '(orderless-prefixes
          orderless-literal
          orderless-strict-leading-initialism
          orderless-regexp
          orderless-flex))
  (setq ace/orderless-alternative-styles
        '(orderless-literal
          orderless-prefixes
          orderless-strict-leading-initialism
          orderless-regexp)))

(ace/elpa-package 'orderless
  (setq orderless-component-separator " +")
  (setq orderless-matching-styles ace/orderless-default-styles)
  (setq orderless-style-dispatchers
'(ace/orderless-literal-dispatcher
  ace/orderless-initialism-dispatcher))
  ;; SPC should never complete: use it for `orderless' groups.
  (let ((map minibuffer-local-completion-map))
    (define-key map (kbd "SPC") nil)
    (define-key map (kbd "?") nil)))
#+end_src

** Completion hint

This is a utility jointly developed by Daniel Mendler and Omar Antolín
Camarena that provides annotations to completion candidates.  It is
meant to be framework-agnostic, so it works with Selectrum, Icomplete
vertical, and Embark (since 2020-12-20, the latter has become my choice
for visualising the standard completion framework's output

#+begin_src emacs-lisp
(ace/elpa-package 'marginalia
  (setq marginalia-annotators
'(marginalia-annotators-heavy
  marginalia-annotators-light))
  (marginalia-mode))
#+end_src

** Minibuffer

#+begin_src emacs-lisp
(ace/builtin-package 'minibuffer
  (setq completion-styles '(partial-completion substring flex orderless))
  (setq completion-category-defaults nil)
  (setq completion-cycle-threshold 3)
  ;; (setq completion-flex-nospace nil)
  ;; (setq completion-pcm-complete-word-inserts-delimiters t)
  ;; (setq completion-pcm-word-delimiters "-_./:| ")
  ;; (setq completion-show-help nil)
  ;; (setq completion-auto-help nil)
  (setq completion-ignore-case t)
  (setq-default case-fold-search t)   ; For general regexp
  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t)

  (setq enable-recursive-minibuffers t)
  (setq read-answer-short t)
  (setq resize-mini-windows t)
  (setq minibuffer-eldef-shorten-default t)

  (setq echo-keystrokes 0.25)           ; from the C source code

  (file-name-shadow-mode 1)
  (minibuffer-depth-indicate-mode 1)
  (minibuffer-electric-default-mode 1)

  ;; (add-hook 'minibuffer-setup-hook (lambda () (keyboard-translate ?\C-i ?\H-z)))
  ;; (add-hook 'minibuffer-exit-hook (lambda () (keyboard-translate ?\C-i ?\C-i)))

  (let ((map minibuffer-local-map))
    ;; (define-key map (kbd "H-z") #'backward-char)
    ;; (define-key map (kbd "C-o") #'forward-char)
    (define-key map (kbd "C-u") #'kill-whole-line)
    (define-key map (kbd "C-w") #'backward-kill-word))


  (let ((map global-map))
    (define-key map (kbd "s-b") #'switch-to-buffer)
    (define-key map (kbd "s-f") #'find-file)
    (define-key map (kbd "s-d") #'dired)))
#+end_src

** Minibuffer commands with consult.el

#+begin_src emacs-lisp
(ace/elpa-package 'consult
  (setq consult-line-numbers-widen t)
  (setq completion-in-region-function #'consult-completion-in-region)
  (setq consult-async-min-input 3)
  (setq consult-async-input-debounce 0.5)
  (setq consult-async-input-throttle 0.8)
  (setq consult-narrow-key ">")
  (setq consult-imenu-config
        '((emacs-lisp-mode :toplevel "Functions"
        :types ((?f "Functions" font-lock-function-name-face)
                (?m "Macros"    font-lock-keyword-face)
                (?p "Packages"  font-lock-constant-face)
                (?t "Types"     font-lock-type-face)
                (?v "Variables" font-lock-variable-name-face)))))
  ;; Registers' setup -- From Consult's README
  ;;
  ;; This gives a consistent display for `consult-register',
  ;; `consult-register-load', `consult-register-store', and the Emacs
  ;; built-ins.
  (setq register-preview-delay 0.2
        register-preview-function #'consult-register-format)
  ;; Tweak the register preview window.
  ;; * Sort the registers
  ;; * Hide the mode line
  ;; * Resize the window, such that the contents fit exactly
  (advice-add #'register-preview :around
      (lambda (fun buffer &optional show-empty)
        (let ((register-alist (seq-sort #'car-less-than-car register-alist)))
        (funcall fun buffer show-empty))
        (when-let (win (get-buffer-window buffer))
        (with-selected-window win
            (setq-local mode-line-format nil)
            (setq-local window-min-height 1)
            (fit-window-to-buffer)))))

  (let ((map global-map))
    (define-key map (kbd "C-x M-:") #'consult-complex-command)
    (define-key map (kbd "C-x M-m") #'consult-minor-mode-menu)
    (define-key map (kbd "C-x M-k") #'consult-kmacro)
    (define-key map (kbd "M-g M-g") #'consult-goto-line)
    (define-key map (kbd "M-X")     #'consult-mode-command)
    (define-key map (kbd "M-K")     #'consult-keep-lines) ; M-S-k is similar to M-S-5 (M-%)
    (define-key map (kbd "M-F")     #'consult-focus-lines) ; same principle
    ;; (define-key map (kbd "M-s g")   #'consult-grep)
    (define-key map (kbd "M-s m")   #'consult-mark)
    (define-key map (kbd "C-x r r") #'consult-register) ; Use the register's prefix
    (define-key map (kbd "C-x r S") #'consult-register-store)
    (define-key map (kbd "C-x r L") #'consult-register-load)
    (define-key consult-narrow-map (kbd "?") #'consult-narrow-help)))

(with-eval-after-load 'consult
  (ace/builtin-package 'ace-consult
    (setq ace/consult-command-centre-list
          '(consult-line
            ace/consult-line
            consult-mark))
    (setq ace/consult-command-top-list
          '(consult-outline
            consult-imenu
            ace/consult-outline
            ace/consult-imenu))
    (ace/consult-set-up-hooks-mode 1)
    (let ((map global-map))
      (define-key map (kbd "M-s i") #'ace/consult-imenu)
      (define-key map (kbd "M-s l") #'ace/consult-line)
      (define-key map (kbd "M-s L") #'ace/consult-outline)
      (define-key map (kbd "M-s y") #'ace/consult-yank))))
#+end_src

** Minibuffer actions with embark.el

#+begin_src emacs-lisp
(ace/elpa-package 'embark
    (setq embark-collect-initial-view-alist
      '((file . list)
        (buffer . list)
        (symbol . list)
        (line . list)
        (xref-location . list)
        (kill-ring . zebra)
        (t . list)))
    (setq embark-quit-after-action t)     ; XXX: Read the doc string!
    (setq embark-key-action-separator (propertize " · " 'face 'shadow))
    (setq embark-action-indicator
        (let ((act (propertize "Act" 'face 'success)))
        (cons act (concat act " on '%s'"))))
    (setq embark-become-indicator (propertize "Become" 'face 'warning))

    (setq embark-action-indicator
          (lambda (map &optional _target)
            (which-key--show-keymap "Embark" map nil nil 'no-paging)
            #'which-key--hide-popup-ignore-command)
          embark-become-indicator embark-action-indicator)

    (define-key global-map (kbd "C-.") #'embark-act)
    (let ((map minibuffer-local-map))
        (define-key map (kbd "C-.") #'embark-act)
        (define-key map (kbd "C-,") #'embark-become))
    (let ((map embark-collect-mode-map))
        (define-key map (kbd "C-.") #'embark-act))
    (let ((map embark-symbol-map))
        (define-key map (kbd ".") #'embark-find-definition)
        (define-key map (kbd "K") #'describe-keymap)))

(with-eval-after-load 'embark
  (ace/builtin-package 'ace-embark
    (ace/embark-extras-keymaps 1)
    (ace/embark-extras-setup-packages 1)
    (let ((map embark-collect-mode-map))
      (define-key map (kbd "C-k") #'ace/embark-collection-kill-line)
      (define-key map (kbd "C-s-n") #'ace/embark-completions-act-next)
      (define-key map (kbd "C-s-p") #'ace/embark-completions-act-previous))))
#+end_src

* Window/Buffer/Tab

I believe that Emacs' true power lies in its buffer management rather
than its multiplexing.  The latter becomes inefficient at scale, since
it tries to emulate the limitations of the real world, namely, the
placement of things on a desk.

By leveraging the power of the computer, we can use search methods to
easily reach any item.  There is no need to remain confined to the idea
of a finite space (screen real estate) that needs to be carefully
managed.

That granted, Emacs' multiplexing can be turned into a powerhouse as
well, covering everything from window placement rules, to the recording
of history and layouts, as well as directional or direct window
navigation.

** Window rules and basic tweaks

The =display-buffer-alist= and all other functions grouped together with
=prot/window-dired-vc-root-left= are considered *experimental and subject
to review*.  The former is intended as a rule-set for controlling the
display of windows.  While the latter serves as a series of tangible
examples of passing certain rules programmatically, in combination with
a few relevant extras.  The objective is to create a more intuitive
workflow where targeted buffer groups or types are always shown in a
given location, on the premise that predictability improves usability.

For each buffer action in =display-buffer-alist= we can define several
functions for selecting the appropriate window.  These are executed in
sequence, but my usage thus far suggests that a simpler method is just
as effective for my case.

Everything pertaining to buffer actions is documented at length in the
GNU Emacs Lisp Reference Manual.  Information can also be found at all
times via =C-h f display-buffer= and, for my particular settings, with
=C-h f display-buffer-in-side-window=.

With regard to the key bindings, most combinations are complementary to
the standard ones, such as =C-x 1= becoming =s-1=, =C-x o= turning into
=s-o= and the like.  They *do not replace* the defaults: they just
provide more convenient access to their corresponding functions.  They
all involve the Super key, following the norms described in the relevant
[[#h:fbba4dea-9cc8-4e73-bffa-02aab10a6703][note on the matter]].  Concerning the =balance-windows-area= I find that
it is less intrusive than the original =balance-windows= normally bound
to the same =C-x +=.

For a demo of the =display-buffer-alist= and the functions that
accompany it, watch my [[https://protesilaos.com/codelog/2020-01-07-emacs-display-buffer/][video on rules for buffer placement]]
(2020-01-07).

#+begin_src emacs-lisp
(ace/builtin-package 'window
  (setq display-buffer-alist
        '(;; top side window
          ("\\*\\(Flymake\\|Package-Lint\\|vc-git :\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 0))
          ("\\*Messages.*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 1))
          ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\)\\*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 2)
           (window-parameters . ((no-other-window . t))))
          ;; bottom side window
          ("\\*\\(Embark\\)?.*Completions.*"
           (display-buffer-in-side-window)
           (side . bottom)
           (slot . 0)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . none))))
          ;; left side window
          ("\\*Help.*"
          ;; ("\\*helpful.*"
           (display-buffer-in-side-window)
           (window-width . 0.35)       ; See the :hook
           (side . left)
           (slot . 0))
          ;; right side window
          ("\\*Faces\\*"
           (display-buffer-in-side-window)
           (window-width . 0.25)
           (side . right)
           (slot . 0))
          ("\\*Custom.*"
           (display-buffer-in-side-window)
           (window-width . 0.25)
           (side . right)
           (slot . 1))
          ("\\*.*\\([^E]eshell\\|shell\\|v?term\\).*"
           ;; (display-buffer-reuse-mode-window display-buffer-in-side-window)
           (display-buffer-pop-up-window)
           (window-width . 0.4)
           (side . right)
           (slot . 0)
           (window-parameters . ((mode-line-format . none))))
          ;; bottom buffer (NOT side window)
          ("\\*\\vc-\\(incoming\\|outgoing\\).*"
           (display-buffer-at-bottom))
          ("\\*\\(Output\\|Register Preview\\).*"
           (display-buffer-at-bottom))))
  (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)

  ;; Disable window close when calling 'keyboard-escape-quit'
  (defadvice keyboard-escape-quit
    (around keyboard-escape-quit-dont-close-windows activate)
    (let ((buffer-quit-function (lambda () ())))
      ad-do-it))

  (add-hook 'help-mode-took #'visual-line-mode)
  (add-hook 'custom-mode-hook #'visual-line-mode)

  (let ((map global-map))
    (define-key map (kbd "s-m") #'ace/simple-monocle)
    (define-key map (kbd "s-z") #'window-toggle-side-windows)))
#+end_src

** Window history (winner-mode)

Winner is a built-in tool that keeps a record of buffer and window
layout changes.  It then allows us to move back and forth in the
history of said changes.  I have it enabled by default, while I assign
its two main functions to Super and the right/left arrow keys.

#+begin_src emacs-lisp
(ace/builtin-package 'winner
  (add-hook 'after-init-hook #'winner-mode)
  (let ((map global-map))
    (define-key map (kbd "s-[") #'winner-redo)
    (define-key map (kbd "s-]") #'winner-undo)))
#+end_src

** Directional window motions (windmove)

Windmove is also built into Emacs.  It provides functions for selecting
a window in any of the cardinal directions.  A decent addition to the
simpler =other-window= command (=C-x o= by default).

The =windmove-create-window= specifies what should happen when trying to
move past the edge of the frame.  The idea with this is to allow it to
create a new window with the contents of the current buffer.  I tried it
for a while but felt that the times it would interfere with my layout
where more than those it would actually speed up my workflow.

#+begin_src emacs-lisp
;; (prot-emacs-builtin-package 'windmove
;;   (setq windmove-create-window nil)     ; Emacs 27.1
;;   (let ((map global-map))
;;     (define-key map (kbd "<C-M-up>") #'windmove-up)
;;     (define-key map (kbd "<C-M-right>") #'windmove-right)
;;     (define-key map (kbd "<C-M-down>") #'windmove-down)
;;     (define-key map (kbd "<C-M-left>") #'windmove-left)))
#+end_src

** Transposition and rotation of windows

The =transpose-frame= library defines a set of commands for shifting the
layout of Emacs windows.  Rather than me describing how these work, I
strongly encourage you to read the "Commentary" section in the source
code.  Do it with =M-x find-library transpose-frame=.

#+begin_src emacs-lisp
;; (prot-emacs-elpa-package 'transpose-frame
;;   (let ((map global-map))
;;     (define-key map (kbd "C-s-t") #'flop-frame) ; what I consider "transpose" in this context
;;     (define-key map (kbd "C-s-r") #'rotate-frame-clockwise)))
#+end_src

** Tabs for window layouts (and ace-tab.el)

Starting with version 27.1, Emacs has built-in support for two distinct
concepts of "tabs":

1. Work spaces that contain windows in any given layout.
2. A list of buffers presented as buttons at the top of the window.

The former, represented by the =tab-bar= library, is best understood as
the equivalent of "virtual desktops", as these are used in most desktop
environments or window managers.

The latter, implemented in =tab-line=, is the same as the tabs you are
used to in web browsers.  Each buffer is assigned to a single tab.
Clicking on the tab takes you to the corresponding buffer.

I do not need the =tab-line= as I find such tabs to be inefficient at
scale.  Finding a buffer through search mechanisms is generally faster:
it does not matter whether you have ten or a hundred buffers on the list
(unless, of course, they all have similar names in which case you are in
trouble either way---do not forget to check my [[#h:06290f9c-491c-45b2-b213-0248f890c83d][Ibuffer settings]]).

On the other hand, the work spaces (=tab-bar=) are very useful for
organising the various applications that are running inside of Emacs.
You can, for example, have your current project on tab (workspace) 1,
your email and news reader on 2, music on 3, and so on.  Of course, this
can also be achieved by using separate frames for each of these, though
I generally prefer working in a single frame (plus you can define a
window configuration or frameset in a register).

For me tabs are useful as groups of buffers in a given window
configuration.  I do not want a persistent bar with buttons that
introduces extra visual clutter.  Switching to tabs is done through
completion, specifically =ace/tab-select-tab-dwim=.

All settings I configure here are meant to work in accordance with this
abstract conception of "tabs are work spaces".  Here are the main key
chords for =tab-bar= (they will all work properly if you keep the mode
active):

| Key     | Description                    |
|---------+--------------------------------|
| C-x t b | Open a buffer in a new tab     |
| C-x t d | Open a directory in a new tab  |
| C-x t f | Open a file in a new tab       |
| C-x t 0 | Close current tab              |
| C-x t 1 | Close all other tabs           |
| C-x t 2 | Open current buffer in new tab |

These are consistent with the standard commands for handling windows and
accessing buffers/files in the "other window" (the =C-x 4 KEY= pattern).
There is also a command for giving a name to the current tab, accessed
via =C-x t r=, though I find I do not use it.

Here my settings, followed by the entirety of =prot-tab.el=.

#+begin_src emacs-lisp
(ace/builtin-package 'tab-bar
  (setq tab-bar-tab-choice "NewTab")
  (setq tab-bar-new-button-show nil)
  (setq tab-bar-close-button-show nil)
  (setq tab-bar-close-last-tab-choice 'tab-bar-mode-disable)
  (setq tab-bar-close-tab-select 'recent)
  (setq tab-bar-new-tab-choice t)
  (setq tab-bar-new-tab-to 'right)
  (setq tab-bar-position nil)
  (setq tab-bar-show nil)
  (setq tab-bar-tab-hints nil)
  (setq tab-bar-tab-name-function 'tab-bar-tab-name-all)
  (tab-bar-mode -1)
  (tab-bar-history-mode -1)
  (let ((map global-map))
    (define-key map (kbd "H-s-<tab>") #'tab-next)
    (define-key map (kbd "H-s-`") #'tab-previous)))

(ace/builtin-package 'ace-tab
  (let ((map global-map))
    (define-key map (kbd "<f1>") #'ace/tab-tab-bar-toggle)
    (define-key map (kbd "C-x t t") #'ace/tab-select-tab-dwim)
    (define-key map (kbd "s-t") #'ace/tab-select-tab-dwim)))
;; ;; This is only included as a reference.
;; (prot-emacs-builtin-package 'tab-line
;;   (global-tab-line-mode -1))
#+end_src


*** Tab-bar tabs in the echo area (tab-bar-echo-area.el)

In the previous section on [[#h:63ad472f-c9c2-40ad-9675-1dc529487788][Tabs for window layouts (and prot-tab.el)]], I
explicitly disable the presentation of the tab bar, even though I still
use its functionality.  This keeps the overall aesthetics minimalist,
which I like.  The problem with such a configuration is that we lose
context: it is no longer possible to determine the number of open tabs
nor understand the position of the current one in the list.

This is where Fritz Grabo's =tab-bar-echo-area.el= enters the fray: it
prints a message in the echo area showing the tab list, while it
highlights the current item.  So we can retain both our minimalism and
the contextuality a bar offers.  Simple, yet super effective!

#+begin_src emacs-lisp
;; (prot-emacs-elpa-package 'tab-bar-echo-area
;;   (tab-bar-echo-area-mode 1))
#+end_src

** Unique names for buffers

These settings make it easier to work with multiple buffers.  When two
buffers have the same name, Emacs will try to disambiguate them by
displaying their element of differentiation in accordance with the style
of =uniquify-buffer-name-style=.  While =uniquify-strip-common-suffix= will
remove the part of the file system path they have in common.

All such operations are reversed once an offending buffer is removed
from the list, allowing Emacs to revert to the standard of displaying
only the buffer's name.

#+begin_src emacs-lisp
(ace/builtin-package 'uniquify
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-strip-common-suffix t)
  (setq uniquify-after-kill-buffer-p t))
#+end_src

** Ibuffer and extras (dired-like buffer list manager)

=ibuffer.el= ships with Emacs and it provides a drop-in replacement for
=list-buffers=.  Compared to its counterpart, it allows for granular
control over the buffer list and is more powerful overall.  For this
reason I bind it to =C-s-b=.

Overview of its features:

- mark and delete buffers same way you do in =dired= (see the previous
  sections on [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][dired (directory editor, file manager)]]);
- mark by a predicate, such as name, major mode, etc.;
- sort buffers by name, filesystem path, major mode, size;
- run =occur= on the marked buffers (remember: Occur produces a buffer
  that you can edit once you enable the editable state with =e=);
- run =query-replace= or =query-replace-regexp= on marked buffers.

Run the universal help command for major mode documentation (=C-h m=)
while inside =ibuffer= to get a detailed list of all available commands
and their key bindings.

With regard to the following package configurations, these are my tweaks
to the default behaviour and presentation:

+ Prompt for confirmation only when deleting a modified buffer.
+ Hide the summary.
+ Do not open on the other window; use the current one.
+ Do not show empty filter groups.
+ Do not cycle movements.  So do not go to the top when moving downward
  at the last item on the list.

Also watch my [[https://protesilaos.com/codelog/2020-04-02-emacs-intro-ibuffer/][introduction to Ibuffer]] (2020-04-02).

Now some extras that I introduced after I published that video, which
pertain to my =prot-ibuffer.el= library (copied in its entirety below the
package configurations):

+ =ace/ibuffer-buffers-major-mode= produces a filtered list of buffers
  that match the major mode of the current buffer and lets you pick one
  using minibuffer completion.  With an optional prefix argument (=C-u=)
  it places the results in an Ibuffer list.

+ =ace/ibuffer-buffers-vc-root= filters the list to items that match the
  current buffer's version-controlled directory.  In practice, this
  fills the same niche as the built-in =project-switch-to-buffer= (for
  Emacs 28+), with the crucial difference that it neither reads from nor
  writes to the list of known projects (also check my configurations for
  [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and ace-project.el)]]).  When called with an
  optional prefix argument, this command puts its matching candidates in
  an Ibuffer view.

For those two I received guidance from Omar Antolín Camarena with regard
to the use of =read-buffer= and the =lambda= passed to it (any errors are my
own).  This method informs other tools that this type of completion
pertains to buffers, so they can adapt accordingly.  See, in particular,
[[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Extended minibuffer actions and more (embark.el and prot-embark.el)]].

#+begin_src emacs-lisp
(ace/builtin-package 'ibuffer
  (setq ibuffer-expert t)
  (setq ibuffer-display-summary nil)
  (setq ibuffer-use-other-window nil)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-movement-cycle nil)
  (setq ibuffer-default-sorting-mode 'filename/process)
  (setq ibuffer-use-header-line t)
  (setq ibuffer-default-shrink-to-minimum-size nil)
  (setq ibuffer-formats
        '((mark modified read-only locked " "
                (name 30 30 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " " filename-and-process)
          (mark " "
                (name 16 -1)
                " " filename)))
  (setq ibuffer-saved-filter-groups nil)
  (setq ibuffer-old-time 48)
  (add-hook 'ibuffer-mode-hook (lambda () (interactive) (hl-line-mode) (ibuffer-update 0)))
  (define-key evil-normal-state-map (kbd "C-s-b") #'ibuffer)
  (let ((map ibuffer-mode-map))
    (define-key map (kbd "* f") #'ibuffer-mark-by-file-name-regexp)
    (define-key map (kbd "* g") #'ibuffer-mark-by-content-regexp) ; "g" is for "grep"
    (define-key map (kbd "* n") #'ibuffer-mark-by-name-regexp)
    (define-key map (kbd "s n") #'ibuffer-do-sort-by-alphabetic)  ; "sort name" mnemonic
    (define-key map (kbd "/ g") #'ibuffer-filter-by-content)))

(ace/builtin-package 'ace-ibuffer
  (let ((map global-map))
    (define-key map (kbd "M-s b") #'ace/ibuffer-buffers-major-mode)
    (define-key map (kbd "M-s g") #'ace/ibuffer-buffers-vc-root)
    (define-key map (kbd "s-x")   #'ace/simple-kill-buffer-current)
    (define-key map (kbd "s-i")   #'next-buffer)
    (define-key map (kbd "s-o")   #'previous-buffer)))
#+end_src

** Scratch buffers per major-mode

This package will produce a buffer that matches the major mode of the
one you are currently in.  Use it with =M-x scratch=.  Doing that with a
prefix argument (=C-u=) will prompt for a major mode instead.  Simple yet
super effective!

The =prot/scratch-buffer-setup= simply adds some text in the buffer and
renames it appropriately for the sake of easier discovery.  I got the
idea of copying the region from [[https://gist.github.com/eev2/52edbfdb645e26aefec19226c0ca7ad0][a snippet shared by eev2 on GitHub]].

#+begin_src emacs-lisp
(ace/elpa-package 'scratch
  ;; TODO 2021-01-19: refine `ace/scratch-buffer-setup'
  (defun ace/scratch-buffer-setup ()
    "Add contents to `scratch' buffer and name it accordingly.
If region is active, add its contents to the new buffer."
    (let* ((mode major-mode)
           (string (format "Scratch buffer for: %s\n\n" mode))
           (region (with-current-buffer (current-buffer)
                     (if (region-active-p)
                         (buffer-substring-no-properties
                          (region-beginning)
                          (region-end)))
                     ""))
           (text (concat string region)))
      (when scratch-buffer
	    (save-excursion
          (insert text)
          (goto-char (point-min))
          (comment-region (point-at-bol) (point-at-eol)))
	    (forward-line 2))
      (rename-buffer (format "*Scratch for %s*" mode) t)))
  (add-hook 'scratch-create-buffer-hook #'ace/scratch-buffer-setup)
  (define-key global-map (kbd "C-c s") #'scratch))
#+end_src

* Development

Packages or custom functions for development.

** Lsp-mode

#+begin_src emacs-lisp
(defun ace/lsp-mode-setup ()
  (setq lsp-keymap-prefix "C-c l")  ;; Or 'C-l', 's-l'
  (setq lsp-enable-which-key-integration t)
  (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols)))

(ace/elpa-package 'lsp-mode (add-hook 'lsp-mode-hook #'ace/lsp-mode-setup))
;; (ace/elpa-package 'lsp-mode)

(ace/elpa-package 'lsp-ui
  (add-hook 'lsp-mode-hook 'lsp-ui-mode)
  (setq lsp-ui-doc-position 'bottom))

(ace/elpa-package 'lsp-treemacs)
#+end_src

** Company-mode

#+begin_src emacs-lisp
(ace/elpa-package 'company
  (add-hook 'after-init-hook 'global-company-mode)
  (setq company-idle-delay 0.0))
  ;; (define-key company-active-map (kbd "C-e") #'company-select-previous)
  ;; (define-key company-active-map (kbd "C-n") #'company-select-next))
#+end_src

** Languages
*** Haskell

#+begin_src emacs-lisp
(ace/elpa-package 'haskell-mode
		  (add-hook 'haskell-mode-hook  #'lsp-deferred))
#+end_src

*** TypeScript

#+begin_src emacs-lisp
(ace/elpa-package 'typescript-mode
		  (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-mode))
		  (add-hook 'typescript-mode-hook  #'lsp-deferred))
#+end_src

*** Tailwindcss

#+begin_src emacs-lisp
(ace/elpa-package 'lsp-tailwindcss)
;; (ace/manual-package 'lsp-tailwindcss)
#+end_src

** Linter
*** Flymake

This is a built-in linter interface. It visualises in a buffer what you would otherwise get on the command-line prompt (or compilation log), while it also marks the line[s] where the note, warning, or error occurs. In short, it is quite a nice tool to have.

Several extensions to Flymake are already available, mostly targeted at programmers. (Flymake can lint Elisp without any further configuration)

The external flymake-diagnostic-at-point package provides a simple and effective interface to displaying information about the warning at point.

#+begin_src emacs-lisp
(ace/builtin-package 'flymake
  (setq flymake-fringe-indicator-position 'left-fringe)
  (setq flymake-suppress-zero-counters t)
  (setq flymake-start-on-flymake-mode t)
  (setq flymake-no-changes-timeout nil)
  (setq flymake-start-on-save-buffer t)
  (setq flymake-proc-compilation-prevents-syntax-check t)
  (setq flymake-wrap-around nil)
  (let ((map flymake-mode-map))
    (define-key map (kbd "C-c ! s") #'flymake-start)
    (define-key map (kbd "C-c ! d") #'flymake-show-diagnostics-buffer)
    (define-key map (kbd "C-c ! n") #'flymake-goto-next-error)
    (define-key map (kbd "C-c ! p") #'flymake-goto-prev-error)))

(ace/elpa-package 'flymake-diagnostic-at-point
		  (setq flymake-diagnostic-at-point-display-diagnostic-function
			'flymake-diagnostic-at-point-display-minibuffer))
#+end_src

** Comment

Emacs' built in commenting functionality =comment-dwim= (usually bound to =M-;=) doesn't always comment things in the way you might expect so we use [[https://github.com/redguardtoo/evil-nerd-commenter][evil-nerd-commenter]] to provide a more familiar behavior.  I've bound it to =M-/= since other editors sometimes use this binding but you could also replace Emacs' =M-;= binding with this command.

#+begin_src emacs-lisp
(ace/elpa-package 'evil-nerd-commenter)
#+end_src

* Utils

** Dired

#+begin_src emacs-lisp
(ace/builtin-package 'dired
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)
  (setq dired-listing-switches
        "-AGFhlv --group-directories-first --time-style=long-iso")
  (setq dired-dwim-target t)
  (add-hook 'dired-mode-hook
            (lambda ()
              (define-key dired-mode-map (kbd "h")
                          (lambda () (interactive) (find-alternate-file "..")))))
  (add-hook 'dired-mode-hook #'dired-hide-details-mode)
  (add-hook 'dired-mode-hook #'hl-line-mode))

(ace/builtin-package 'dired-aux
  (setq dired-isearch-filenames 'dwim)
  ;; The following variables were introduced in Emacs 27.1
  (setq dired-create-destination-dirs 'ask)
  (setq dired-vc-rename-file t)

  ;; Those two functions are copied from the Emacs config of Omar
  ;; Antolín Camarena: <https://github.com/oantolin/emacs-config>.
  (defun contrib/cdb--bookmarked-directories ()
    (bookmark-maybe-load-default-file)
    (cl-loop for (name . props) in bookmark-alist
             for fn = (cdr (assq 'filename props))
             when (and fn (string-suffix-p "/" fn))
             collect (cons name fn)))

  (defun contrib/cd-bookmark (bm)
    "Insert the path of a bookmarked directory."
    (interactive
     (list (let ((enable-recursive-minibuffers t))
             (completing-read
              "Directory: " (contrib/cdb--bookmarked-directories) nil t))))
    (when (minibufferp)
      (delete-region (minibuffer-prompt-end) (point-max)))
    (insert (cdr (assoc bm (contrib/cdb--bookmarked-directories)))))

  (let ((map dired-mode-map))
    ;; (define-key map (kbd "h") #'dired-up-directory)
    ;; (define-key map (kbd "SPC") nil)
    (define-key map (kbd "s-j") #'dired-jump-other-window)
    (define-key map (kbd "_") #'dired-create-empty-file)
    (define-key map (kbd "i") #'dired-toggle-read-only)
    (define-key map (kbd "I") #'dired-maybe-insert-subdir)
    (define-key map (kbd "M-s f") #'nil)
    (define-key map (kbd "C-x v v") #'dired-vc-next-action)) ; Emacs 28
  (define-key minibuffer-local-filename-completion-map (kbd "C-c d") #'contrib/cd-bookmark))

;; (ace/builtin-package 'dired-x
;;   (setq dired-clean-up-buffers-too t)
;;   (setq dired-clean-confirm-killing-deleted-buffers t)
;;   (setq dired-x-hands-off-my-keys t)    ; easier to show the keys I use
;;   (setq dired-bind-man nil)
;;   (setq dired-bind-info nil)
;;   (define-key dired-mode-map (kbd "I") #'dired-info))

(ace/elpa-package 'dired-subtree
  (setq dired-subtree-use-backgrounds nil)
  (let ((map dired-mode-map))
    (define-key map (kbd "<tab>") #'dired-subtree-toggle)
    (define-key map (kbd "<C-tab>") #'dired-subtree-cycle)
    (define-key map (kbd "<S-iso-lefttab>") #'dired-subtree-remove)))

(ace/builtin-package 'wdired
  (setq wdired-allow-to-change-permissions t)
  (setq wdired-create-parent-directories t))

(ace/builtin-package 'image-dired
  (setq image-dired-external-viewer "xdg-open")
  (setq image-dired-thumb-size 80)
  (setq image-dired-thumb-margin 2)
  (setq image-dired-thumb-relief 0)
  (setq image-dired-thumbs-per-row 4)
  (define-key image-dired-thumbnail-mode-map
    (kbd "<return>") #'image-dired-thumbnail-display-external))

;; part of `async' package
(ace/builtin-package 'dired-async
  (add-hook 'dired-mode-hook #'dired-async-mode))
#+end_src

** EAF

#+begin_src emacs-lisp
(ace/elpa-package 'epc)
(ace/elpa-package 'deferred)
(ace/builtin-package 'eaf
  (setq eaf-browser-continue-where-left-off t)
  (eaf-bind-key nil "M-o" eaf-browser-keybinding)
  ;; (eaf-setq eaf-browse-blank-page-url "https://duckduckgo.com")
  (eaf-setq eaf-browser-enable-adblocker "true")
  (eaf-setq eaf-browser-default-zoom "1.75"))

#+end_src

** Org-mode

#+begin_src emacs-lisp
(defun ace/org-interface-setup()
  (variable-pitch-mode) ;; use different fonts in org-mode buffer
  (org-indent-mode)
  (visual-line-mode)
  (font-lock-add-keywords 'org-mode ;; replace list hyphen with dot
                          '(("^ *\\([-]\\) "
                          (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
  (let* ((variable-tuple
        ;; (cond ((x-list-fonts "JetBrains Mono")  '(:font "JetBrains Mono"))
        ;; (cond ((x-list-fonts "Iosevka SS04")    '(:font "Iosevka ss04"))
        (cond ((x-list-fonts "Sarasa Mono SC")  '(:font "Sarasa Mono SC"))
              ((x-list-fonts "ETBembo")         '(:font "ETBembo"))
              ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
              ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
              (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
      ; (base-font-color     (face-foreground 'default nil 'default))
      (base-font-color     (face-foreground 'font-lock-string-face nil 'default))
      (headline           `(:inherit default :weight bold :foreground ,base-font-color)))
    (custom-theme-set-faces 'user
    `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
    `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.2))))
    `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.3))))
    `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.5))))))
  ;; ensure that anything that should be fixed-pitch in Org files appears that way
  (custom-theme-set-faces 'user
  '(org-block ((t (:inherit fixed-pitch))))
  '(org-code ((t (:inherit (shadow fixed-pitch)))))
  '(org-document-info ((t (:foreground "dark orange"))))
  '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
  '(org-indent ((t (:inherit (org-hide fixed-pitch)))))
  '(org-link ((t (:foreground "royal blue" :underline t))))
  '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
  '(org-property-value ((t (:inherit fixed-pitch))) t)
  '(org-checkbox ((t (:inherit fixed-pitch))) t)
  '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
  '(org-table ((t (:inherit fixed-pitch :foreground "#83a598"))))
  '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
  '(org-verbatim ((t (:inherit (shadow fixed-pitch)))))))

(ace/builtin-package 'org
  (add-hook 'org-mode-hook #'ace/org-interface-setup)
  (add-hook 'org-tab-first-hook #'org-end-of-line)
  (setq org-adapt-indentation nil)
  (setq org-hide-leading-stars t)
  (setq org-startup-folded t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-edit-src-content-indentation 0)
  (setq org-ellipsis " ▾")
  (setq org-hide-emphasis-markers t)
  (setq org-agenda-start-with-log-mode t)
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  (let ((map org-mode-map))
    (define-key map (kbd "C-'") nil)
    (define-key map (kbd "C-o") #'forward-char)
    ;; (define-key map (kbd "C-,") nil)
    (define-key map (kbd "<C-return>") nil)
    (define-key map (kbd "<C-S-return>") nil)
    (define-key map (kbd "C-c S-l") #'org-toggle-link-display)
    (define-key map (kbd "C-c C-S-l") #'org-insert-last-stored-link)))

;; Heading bullets
(ace/elpa-package 'org-superstar
  (add-hook 'org-mode-hook #'org-superstar-mode)
  (setq org-superstar-remove-leading-stars t)
  (setq org-superstar-headline-bullets-list '("◉" "○" "●" "○" "●" "○" "●")))

;; Center Org Buffers
(ace/elpa-package 'visual-fill-column
  (defun ace/org-mode-visual-fill ()
    (setq visual-fill-column-width 120
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))
  (add-hook 'org-mode-hook #'ace/org-mode-visual-fill))

;; org-habit
(ace/builtin-package 'org-habit
    (add-to-list 'org-modules 'org-habit)
    (setq org-habit-graph-column 60))

;; org-babel
(org-babel-do-load-languages
  'org-babel-load-languages
  '((emacs-lisp . t)
    (python . t)
    (haskell . t)))
(push '("conf-unix" . conf-unix) org-src-lang-modes)

;; org-tempo
(ace/builtin-package 'org-tempo ; this is needed as of Org 9.2
    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("hk" . "src haskell"))
    (add-to-list 'org-structure-template-alist '("py" . "src python")))
#+end_src

** Vterm

#+begin_src emacs-lisp
(ace/elpa-package 'vterm
  (setq vterm-always-compile-module t)
  (defun ace/vterm-send-key (key &optional shift meta ctrl)
    "Send KEY to libvterm with optional modifiers SHIFT, META and CTRL."
    (deactivate-mark)
    (when vterm--term
      (let ((inhibit-redisplay t)
            (inhibit-read-only t))
        (when (and (not (symbolp last-input-event)) shift (not meta) (not ctrl))
          (setq key (upcase key)))
        (vterm--update vterm--term key shift meta ctrl)
        (setq vterm--redraw-immididately t)
        (when (not (eq evil-state 'insert))
          (accept-process-output vterm--process vterm-timer-delay nil t)))))
  (advice-add 'vterm-send-key :override #'ace/vterm-send-key)
  (add-hook 'vterm-mode-hook (lambda ()
    (evil-define-key 'insert 'local [escape] #'vterm-send-escape)
    (evil-define-key 'insert 'local (kbd "<C-return>") '(lambda () (interactive) (vterm-send-key "<f5>")))
    (evil-define-key 'insert 'local (kbd "C-i") '(lambda () (interactive) (vterm-send-key "<f6>")))
    (set (make-local-variable 'buffer-face-mode-face) 'fixed-pitch)
    (vterm-reset-cursor-point)
    (buffer-face-mode t)))
  (define-key global-map (kbd "s-v") #'vterm))
#+end_src

** Version control 

#+begin_src emacs-lisp
(ace/elpa-package 'magit
  (setq magit-define-global-key-bindings nil)
  (define-key global-map (kbd "C-c g") #'magit-status)

  (require 'git-commit)
  (setq git-commit-summary-max-length 50)
  (setq git-commit-known-pseudo-headers
        '("Signed-off-by"
          "Acked-by"
          "Modified-by"
          "Cc"
          "Suggested-by"
          "Reported-by"
          "Tested-by"
          "Reviewed-by"))
  (setq git-commit-style-convention-checks
        '(non-empty-second-line
          overlong-summary-line))

  ;; (let ((map magit-mode-map))
  ;;   (define-key map (kbd "<C-return>") #'magit-diff-visit-file-other-window))

  (require 'magit-diff)
  ;; (let ((map magit-mode-map))
  ;;   (define-key map (kbd "C-<return>") #'magit-diff-visit-file-other-window))
  (define-key magit-diff-section-base-map (kbd "<C-return>") #'magit-diff-visit-file-other-window)
  (setq magit-diff-refine-hunk t)

  (require 'magit-repos)
  (setq magit-repository-directories
        '(("~/Dev" . 1))))

(ace/elpa-package 'git-gutter
  (custom-set-variables
  '(git-gutter:modified-sign "⏽") 
  '(git-gutter:added-sign "⏽")   
  '(git-gutter:deleted-sign "⏽"))
  (global-git-gutter-mode +1))
;; (use-package magit
;;   :custom
;;   (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))
;; NOTE: Make sure to configure a GitHub token before using this package!
;; - https://magit.vc/manual/forge/Token-Creation.html#Token-Creation
;; - https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started
;; (use-package forge)
#+end_src

** Project management (project.el)

#+begin_src emacs-lisp
(ace/builtin-package 'project
  (setq project-switch-commands
    '((?f "File" project-find-file)
      ;; (?s "Subdir" ace/project-find-subdir)
      (?g "Grep" project-find-regexp)
      (?d "Dired" project-dired)
      (?b "Buffer" project-switch-to-buffer)
      (?q "Query replace" project-query-replace-regexp)
      ;; (?t "Tag switch" ace/project-retrieve-tag)
      ;; (?m "Magit" ace/project-magit-status)
      (?v "VC dir" project-vc-dir)
      ;; (?l "Log VC" ace/project-commit-log)
      (?e "Eshell" project-eshell))))

(ace/builtin-package 'ace-project
  (setq ace/project-project-roots '("~/Dev/" "~/"))
  (setq ace/project-commit-log-limit 25)
  (setq ace/project-large-file-lines 1000)
  (let ((map global-map))
    (define-key map (kbd "C-x p <delete>") #'ace/project-remove-project)
    (define-key map (kbd "C-x p l") #'ace/project-commit-log)
    (define-key map (kbd "C-x p m") #'ace/project-magit-status)
    (define-key map (kbd "C-x p s") #'ace/project-find-subdir)
    (define-key map (kbd "C-x p t") #'ace/project-retrieve-tag)))

  (defun my-short-wikipedia-link ()
    "Target a link at point of the form wikipedia:Page_Name."
    (save-excursion
      (let* ((beg (progn (skip-chars-backward "[:alnum:]_:") (point)))
            (end (progn (skip-chars-forward "[:alnum:]_:") (point)))
            (str (buffer-substring-no-properties beg end)))
        (save-match-data
          (when (string-match "wikipedia:\\([[:alnum:]_]+\\)" str)
            (cons 'url (format "https://en.wikipedia.org/wiki/%s"
                              (match-string 1 str))))))))
  (add-to-list 'embark-target-finders 'my-short-wikipedia-link)
#+end_src

** Trash (trashed.el)

=trashed= applies the principles of =dired= to the management of the user's
filesystem trash.  Use =C-h m= to see the docs and keybindings for its
major mode.

Basically, its interaction model is as follows:

- =m= to mark for some deferred action, such as =D= to delete, =R= to restore.
- =t= to toggle the status of all items as marked.  Use this without marks
  to =m= (mark) all items, then call a deferred action to operate on them.
- =d= to mark for permanent deletion.
- =r= to mark for restoration.
- =x= to execute these special marks.

#+begin_src emacs-lisp
(ace/elpa-package 'trashed
  (setq trashed-action-confirmer 'y-or-n-p)
  (setq trashed-use-header-line t)
  (setq trashed-sort-key '("Date deleted" . t))
  (setq trashed-date-format "%Y-%m-%d %H:%M:%S"))
#+end_src

** Leader key (general.el)

#+begin_src emacs-lisp
(ace/elpa-package 'general
  (general-create-definer ace/leader-key
    :states '(normal insert visual emacs)
    :keymaps 'override
    :prefix "SPC"
    :global-prefix "H-SPC")
  (ace/leader-key
      "e"     '(:ignore t :which-key "Eval")
      "ee"    #'eval-last-sexp
      "ex"    #'eval-expression
      "f"     '(:ignore t :which-key "File")
      "fr"    #'ace/simple-rename-file-and-buffer
      "fw"    #'save-buffer
      "g"     '(:ignore t :which-key "Git")
      "gg"    #'magit-status
      "p"     '(:ignore t :which-key "Project")
      "SPC"   #'project-find-file
      "pp"    #'project-switch-project
      "s"     '(:ignore t :which-key "Search")
      "sb"    #'ace/ibuffer-buffers-major-mode
      "sv"    #'ace/ibuffer-buffers-vc-root
      "si"    #'ace/consult-imenu
      "sl"    #'ace/consult-line
      "sL"    #'ace/consult-outline
      "sy"    #'ace/consult-yank
      "r"     '(:ignore t :which-key "Replace")
      "ro"    #'ace/search
      "rO"    #'ace/search
      "t"     '(:ignore t :which-key "Toggle")
      "tt"    #'vterm
      "w"     '(:ignore t :which-key "Window")
      "wv"    #'split-window-right
      "ws"    #'split-window-below
      "wo"    #'delete-other-windows
      "ww"    #'other-window
      "wx"    #'delete-other-windows-vertically
      "w-"    #'balance-windows
      "w="    #'balance-windows-area
      "/"     #'evilnc-comment-or-uncomment-lines
      "."     (lambda () (interactive) (find-file ace/emacs-init-org-path))))

(ace/manual-package 'eaf-evil
  (setq eaf-evil-leader-keymap general-override-mode-map)
  (define-key key-translation-map (kbd "SPC")
      (lambda (prompt)
        (if (derived-mode-p 'eaf-mode)
            (pcase eaf--buffer-app-name
              ("browser" (if (string= (eaf-call-sync "call_function" eaf--buffer-id "is_focus") "True")
                            (kbd "SPC")
                          (kbd eaf-evil-leader-key)))
              ("pdf-viewer" (kbd eaf-evil-leader-key))
              ("image-viewer" (kbd eaf-evil-leader-key))
              (_  (kbd "SPC")))
          (kbd "SPC")))))
#+end_src

