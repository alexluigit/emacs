#+TITLE: Emacs Configuration
#+AUTHOR: Alen Lu
#+EMAIL: alexluigit@gmail.com

* Overview

My Emacs configuration file written in org format.

** Project structure

- Init file (init.el / early-init.el)
- Custom libraries (lisp/*)
- Main config file (ace.org)

** Usage

doc

** Dependencies

doc

* Basic
** Backups

#+begin_src emacs-lisp
(setq auto-save-list-file-prefix nil)
(setq auto-save-default nil)
(setq make-backup-files nil)
(setq auto-save-list-file-prefix nil)
#+end_src

** Auto appending

When you install a package or use the various customisation interfaces to tweak
things to your liking, Emacs will append a piece of Elisp to your init file. In
my experience, this is a common source of inconsistencies, arising from a
conflict between the user's code and what is stored in that custom snippet.

As it does not seem possible to outright disable this behaviour, I instruct
Emacs to place all "custom" code in a temporary file that never gets
loaded. This feels kinda hacky but is better than having some arbitrary code
that you accidentally evaluated from messing up with your carefully designed
(and version-controlled) configuration.

#+begin_src emacs-lisp
(put 'list-timers 'disabled nil)
(put 'erase-buffer 'disabled nil)
(setq custom-file "/tmp/ace-emacs-custom.el")
#+end_src

** History / State

This section contains configurations for packages that are dedicated to
the task of recording the state of various Emacs tools, such as the
history of the minibuffer or the list of recently visited files.

In practice, these are some of the most useful configurations one can
make, as lots of functions depend on them. For example, a record of the
minibuffer's history of inputs allows the completion framework to guess
the most likely course of action. Typing =M-x g= gives me =gnus= as the
first possible option, which is exactly what I want.

** Async facilities

This package provides some asynchronous processing facilities for
various Emacs interfaces, such as for Dired's copy and rename operations
(also read [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][Dired (directory editor, file manager)]]).

#+begin_src emacs-lisp
(use-package async)
#+end_src

** Simple (ace-simple.el)

=ace-simple.el= contains a wide range of commands that are broadly in line with the built-in =simple.el= and =lisp.el= libraries.

#+begin_src emacs-lisp
(use-package ace-simple
  :straight nil
  :commands
  (list ace/simple-kill-window-current
        ace/simple-winmove-r/d
        ace/simple-winmove-l/u)
  :config
  (setq ace/simple-date-specifier "%F")
  (setq ace/simple-time-specifier "%R %z")
  :bind
  (("C-c i" . ace/simple-insert-date)
   ("C-c e" . ace/simple-escape-url)
   ("C-c q" . ace/simple-unfill-region-or-paragraph)
   ("C-<f2>" . ace/simple-rename-file-and-buffer)
   ("C-=" . count-words)
   ("<escape>" . keyboard-escape-quit)))
#+end_src

** Help (help[ful].el)

A better help buffer.

#+begin_src emacs-lisp
(use-package helpful
  :bind
  ("C-h K" . #'describe-keymap)  ; overrides `Info-goto-emacs-key-command-node'
  ([remap describe-function] . #'helpful-callable)
  ([remap describe-variable] . #'helpful-symbol)
  ([remap describe-key] . #'helpful-key)
  :config
  (add-hook 'help-mode-hook #'visual-line-mode)
  (setq help-window-select t))
#+end_src

** Info (info.el)

Change some annoying keybindings in Info-mode.

#+begin_src emacs-lisp
#+end_src

* Text Editing
** Evil

For text editing, I use =evil= mode, which stand for 'emacs vim emulation layer'
or something like that.

*** Basic & extras (evil-mode.el / ace-evil.el)

#+begin_src emacs-lisp
(use-package evil
  :init
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
  (setq evil-disable-insert-state-bindings t)
  (setq evil-want-Y-yank-to-eol t)
  (setq evil-want-C-u-scroll t)
  (setq evil-want-C-i-jump t)
  :config
  (evil-mode)
  (setq evil-echo-state nil)                      ;; We have state in modeline
  (setq evil-regexp-search t)                     ;; Use regex when search with '/' and '?'
  (setq-default evil-jumps-cross-buffers nil)     ;; Don't jump to other buffer when C-i/o
  (evil-set-undo-system 'undo-redo)
  (evil-global-set-key 'normal "p" nil)           ;; Need to be unbound first
  (evil-global-set-key 'normal (kbd "C-.") nil)
  (require 'ace-evil)
  (evil-define-key 'motion global-map "n"            #'evil-next-visual-line)
  (evil-define-key 'motion global-map "p"            #'evil-previous-visual-line)
  (evil-define-key 'motion global-map "N"            #'evil-join)
  (evil-define-key 'normal global-map "P"            #'helpful-at-point)
  (evil-define-key 'normal global-map "U"            #'evil-redo)
  (evil-define-key 'insert global-map (kbd "C-u")    #'evil-delete-back-to-indentation)
  (evil-define-key 'insert global-map (kbd "C-w")    #'evil-delete-backward-word)
  (evil-define-key 'insert global-map (kbd "C-i")    #'backward-char)
  (evil-define-key 'insert global-map (kbd "C-o")    #'forward-char)
  (evil-define-key 'visual global-map ">"            #'ace/evil-shift-right)
  (evil-define-key 'visual global-map "<"            #'ace/evil-shift-left)
  (evil-define-key 'visual global-map (kbd "C-s")    #'ace/evil-visual-search-forward)
  (evil-define-key 'visual global-map (kbd "C-r")    #'ace/evil-visual-search-backward)
  (evil-define-key '(normal insert) global-map (kbd "s-<f6>")   #'evil-paste-after)
  (evil-define-key '(normal insert) global-map (kbd "s-S-<f6>") #'evil-paste-before)
  (evil-set-initial-state 'dired-mode 'emacs)
  (evil-set-initial-state 'vterm-mode 'emacs)
  (evil-set-initial-state 'nov-mode 'emacs)
  (evil-set-initial-state 'eaf-mode 'emacs))
#+end_src

*** Compatability (evil-collection.el)

#+begin_src emacs-lisp
(use-package evil-collection
  :after evil
  :config
  (evil-collection-init '(rg vterm helpful help)))
#+end_src

*** Symbols pairs (evil-surround.el)

#+begin_src emacs-lisp
(use-package evil-surround
  :config
  (global-evil-surround-mode 1))
#+end_src

*** Better 's' key (evil-snipe.el)

#+begin_src emacs-lisp
(use-package evil-snipe
  :config
  (evil-snipe-mode +1) (evil-snipe-override-mode 1))
#+end_src

*** Pulse highlight (evil-goggles.el)

This is another package by Daniel Mendler which pulses the area where
some change took effect.  It is a subtle, yet effective, method to
visually capture the affected region of text and, thus, be confident
that no mistakes were made in the process (or notice those as they
occur).

#+begin_src emacs-lisp
(use-package evil-goggles
  :config (evil-goggles-mode))
#+end_src

** Lines / Paragraphs (ace-fill.el)

The =ace-fill.el= library (reproduced below) is a tiny wrapper around
some Emacs settings and modes that are scrattered around several files,
which control (i) how paragraphs or comments in programming modes should
be wrapped to a given column count, and (ii) what constitutes a
sentence.  I put them all together here to make things easier to track.
+ With regard to paragraphs, I find that a double space is the best way
  to delimit sentences in source form, where a monospaced typeface is
  customary.  There is no worry that this will be shown on a website or
  rendered version of a document, because processors know how to handle
  spacing.  We do this to make phrases easier to tell apart, but also to
  render unambiguous commands like =forward-sentence=.
+ =ace/fill-fill-mode= sets my desired default column width for all
  buffers, while it applies another value for programming modes (in case
  there is a need to control the two cases separately).  Those values
  are stored in the variables =ace/fill-default-column= and
  =ace/fill-prog-mode-column= respectively.  My minor mode also enables
  =auto-fill-mode= in =text-mode= and =prog-mode= buffers through the
  appropriate hooks.  Disabling =ace/fill-fill-mode= will remove all
  those customisations.

#+begin_src emacs-lisp
(use-package ace-fill
  :straight nil
  :config
  (setq-default truncate-lines t)
  (setq ace/fill-default-column 80)
  (setq ace/fill-prog-mode-column 80)  ; Set this to another value if you want
  (setq sentence-end-double-space t)
  (setq sentence-end-without-period nil)
  (setq colon-double-space nil)
  (setq use-hard-newlines nil)
  (setq adaptive-fill-mode t)
  (ace/fill-fill-mode 1))
#+end_src

** Symbols (electric.el and paren.el)

Emacs labels as =electric= any behaviour that involves contextual
auto-insertion of characters.  This is a summary of my settings:

+ Indent automatically.
+ If =electric-pair-mode= is enabled (which I might do manually), insert
  quotes and brackets in pairs.  Only do so if there is no alphabetic
  character after the cursor.
  + To get those numbers, evaluate =(string-to-char CHAR)= where CHAR is
    the one you are interested in.  For example, get the literal tab's
    character with =(string-to-char "\t")=.
+ While inputting a pair, inserting the closing character will just skip
  over the existing one, rather than add a new one.  So typing =(= will
  insert =()= and then typing =)= will just be the same as moving forward
  one character =C-f=.
+ Do not skip over whitespace when operating on pairs.  Combined with
  the above point, this means that a new character will be inserted,
  rather than be skipped over.  I find this better, because it prevents
  the point from jumping forward, plus it allows for more natural
  editing.
+ The rest concern the conditions for transforming quotes into their
  curly equivalents.  I keep this disabled, because curly quotes are
  distinct characters.  It is difficult to search for them.  Just note
  that on GNU/Linux you can type them directly by hitting the "compose"
  key and then an angled bracket (=<= or =>=) followed by a quote mark.


#+begin_src emacs-lisp
(use-package electric
  :config
  (setq electric-pair-inhibit-predicate'electric-pair-conservative-inhibit)
  (setq electric-pair-preserve-balance t)
  (setq electric-pair-pairs
        '((8216 . 8217)
          (8220 . 8221)
          (171 . 187)))
  (setq electric-pair-skip-self 'electric-pair-default-skip-self)
  (setq electric-pair-skip-whitespace nil)
  (setq electric-pair-skip-whitespace-chars '(9 10 32))
  (setq electric-quote-context-sensitive t)
  (setq electric-quote-paragraph t)
  (setq electric-quote-string nil)
  (setq electric-quote-replace-double t)
  (electric-indent-mode 1)
  (electric-pair-mode 1)
  (electric-quote-mode -1))
#+end_src

** Tabs / indentation

I believe tabs, in the sense of inserting the tab character, are best
suited for indentation.  While spaces are superior at precisely aligning
text.  However, I understand that elisp uses its own approach, which I
do not want to interfere with.  Also, Emacs tends to perform alignments
by mixing tabs with spaces, which /can actually lead to misalignments/
depending on certain variables such as the size of the tab.  As such, I
am disabling tabs by default.

If there ever is a need to use different settings in other modes, we can
customise them via hooks.  This is not an issue I have encountered yet
and am therefore refraining from solving a problem that does not affect
me.

Note that =tab-always-indent= will first do indentation and then try to
complete whatever you have typed in.

#+begin_src emacs-lisp
(setq-default tab-always-indent 'complete)
(setq-default tab-first-completion 'word-or-paren-or-punct) ; Emacs 27
(setq-default tab-width 2)
(setq-default indent-tabs-mode nil)
(setq-default evil-shift-width tab-width)
#+end_src

** Search / Replace
*** Regular expressions (re-builder.el)

To learn more about regular expressions, read the relevant pages in
the official manual.  Assuming you have this installed properly on
your system, run =C-h r i regexp= to get to the starting chapter.

Emacs offers a built-in package for practising regular expressions.
By default, =re-builder= uses Emacs-style escape notation, in the form
of double backslashes.  You can switch between the various styles by
using =C-c TAB= inside of the regexp builder's buffer.  I choose to keep
this style as the default.  Other options are =string= and =rx=.

#+begin_src emacs-lisp
(use-package re-builder
  :config
  (setq reb-re-syntax 'read))
#+end_src

*** Writable grep (wgrep.el)

With =wgrep= we can directly edit the results of a =grep= and save the
changes to all affected buffers.  In principle, this is the same as what
the built-in =occur= offers.  We can use it to operate on a list of
matches by leveraging the full power of Emacs' editing capabilities
(e.g. keyboard macros, query and replace a regexp...).

#+begin_src emacs-lisp
(use-package wgrep
  :config
  (setq wgrep-auto-save-buffer t)
  (setq wgrep-change-readonly-file t)
  ;; Press `dd' to delete lines in `wgrep-mode' in evil directly
  (defadvice evil-delete (around evil-delete-hack activate)
    ;; make buffer writable
    (if (and (boundp 'wgrep-prepared) wgrep-prepared)
        (wgrep-toggle-readonly-area))
    ad-do-it
    ;; make buffer read-only
    (if (and (boundp 'wgrep-prepared) wgrep-prepared)
        (wgrep-toggle-readonly-area)))
  :bind
  (:map wgrep-mode-map
        ("M-n" . next-error-no-select)
        ("M-p" . previous-error-no-select)))
#+end_src

*** Cross-references (xref.el)

Xref provides helpful commands for code navigation and discovery, such
as =xref-find-definitions= (=M-.=) and its counterpart =xref-pop-marker-stack=
(=M-,=).  It is a library that gets used by a variety of tools, including
=project.el= (see [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and ace/project.el)]]).

#+begin_src emacs-lisp
(use-package xref
  :config
  ;; All those have been changed for Emacs 28
  (setq xref-show-definitions-function #'xref-show-definitions-completing-read)
  (setq xref-show-xrefs-function #'xref-show-definitions-completing-read)
  (setq xref-file-name-display 'project-relative)
  (setq xref-search-program 'ripgrep))
#+end_src

*** Ripgrep (rg.el)

#+begin_src emacs-lisp
(use-package rg
  :custom
  (rg-command-line-flags '("--context 3"))
  :config
  (rg-define-search ace/rg-project-dwim
    "Run ripgrep with every file (respect ignore) in current
project. Use word at point, no prompt."
    :files "everything"
    :query point
    :dir project))
#+end_src

** Focus

#+begin_src emacs-lisp
(use-package visual-fill-column)
#+end_src

* Interface

General interface section including fontface/icon/etc function
definition.

** GUI / Frame

Change some default frame configuration to my liking.

*** Terminal key fix

For historical reason, terminal can not tell the difference between some key
storkes. For example, =C-i= and =Tab=, =C-m= and =Return=, etc. By default, emacs follow
this convention, but it doesn't mean emacs are not able to tell the
difference. To change this behaviour, we can use =input-decode-map= to give, for
example, =C-m= different meaning.

#+begin_src emacs-lisp
(defun ace/key-fix (&optional frame)
  "To distinguish C-m from RET."
  (with-selected-frame (or frame (selected-frame))
    (when window-system
      (define-key input-decode-map [?\C-m] [C-m]))))
(add-hook 'after-make-frame-functions #'ace/key-fix)
(define-key global-map (kbd "<C-m>") #'call-last-kbd-macro)
#+end_src

*** Fringe-mode

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(internal-border-width . 30))
(fringe-mode 1)
#+end_src

*** Window divider

This is a built-in mode that draws vertical window borders in a slightly
different way than the default, which I find more consistent.  Only
using it because of that, though it can also adjust the size of the
# borders as well as their placement.

#+begin_src emacs-lisp
(setq window-divider-default-right-width 10)
(setq window-divider-default-places 'right-only)
(add-hook 'after-init-hook #'window-divider-mode)
#+end_src

** Theme & icons

#+begin_src emacs-lisp
(use-package doom-themes
  :config
  (load-theme 'doom-dracula t))
;; (load-theme 'modus-vivendi)

(use-package all-the-icons)
#+end_src

** Better modeline (doom-modeline.el)

#+begin_src emacs-lisp
(use-package doom-modeline
  :config
  (doom-modeline-mode t)
  (column-number-mode)
  (setq doom-modeline-height 30)
  (setq doom-modeline-major-mode-icon t))
#+end_src

** Fontface (ace-font.el)

#+begin_src emacs-lisp
(use-package ace-fonts
  :straight nil
  :config
  (setq ace/font-size 140)
  (setq ace/zh-font-size 31)
  (setq ace/default-fonts '("Iosevka SS04" "Victor Mono" "Microsoft Yahei" "STHeiti"))
  (setq ace/fixed-fonts '("Victor Mono" "Fira Code Retina"))
  (setq ace/variable-fonts '("Iosevka SS04" "Victor Mono" "Fira Code Retina"))
  (setq ace/zh-fonts '("Sarasa Mono SC" "PingFang SC" "Microsoft Yahei"))
  (setq ace/org-fonts '("Iosevka SS04" "ETBembo" "Fira Code Retina"))
  (setq ace/zh-font-scale 1))
#+end_src

** Line Number

#+begin_src emacs-lisp
(global-display-line-numbers-mode t)
(dolist (mode '(org-mode-hook
                nov-mode-hook
                term-mode-hook
                shell-mode-hook
                treemacs-mode-hook
                eshell-mode-hook
                rg-mode-hook
                dired-mode-hook
                vterm-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))
#+end_src

** Parentheses (paren.el / rainbow-delimiters.el)

Configure the mode that highlights matching delimiters or parentheses.
I consider this of utmost importance when working with languages such as
elisp.

Summary of what these do:

- Activate the mode upon startup.
- Show the matching delimiter/parenthesis if on screen, else show
  nothing.  It is possible to highlight the expression enclosed by the
  delimiters, by using either =mixed= or =expression=.  The latter always
  highlights the entire balanced expression, while the former will only
  do so if the matching delimiter is off screen.
- =show-paren-when-point-in-periphery= lets you highlight parentheses even
  if the point is in their vicinity.  This means the beginning or end of
  the line, with space in between.  I used that for a long while and it
  server me well.  Now that I have a better understanding of Elisp, I
  disable it.
- Do not highlight a match when the point is on the inside of the
  parenthesis.
- Use rainbow color for delimiters

#+begin_src emacs-lisp
(use-package paren
  :config
  (setq show-paren-style 'parenthesis)
  (setq show-paren-when-point-in-periphery nil)
  (setq show-paren-when-point-inside-paren nil)
  :hook
  (after-init . show-paren-mode))

(use-package rainbow-delimiters
  :hook
  (prog-mode . rainbow-delimiters-mode))
#+end_src

** Scrolling behaviour

By default, page scrolling should keep the point at the same visual
position, rather than force it to the top or bottom of the viewport.
This eliminates the friction of guessing where the point has warped to.

As for per-line scrolling, I dislike the default behaviour of visually
re-centring the point: it is too aggressive as a standard mode of
interaction.  With the following =setq-default=, the point will stay at
the top/bottom of the screen while moving in that direction (use =C-l= to
reposition it).

#+begin_src emacs-lisp
(setq-default scroll-preserve-screen-position t)
(setq-default scroll-conservatively 1) ; affects `scroll-step'
(setq-default auto-window-vscroll nil)
(setq-default scroll-margin 0)
#+end_src

** Keybinding Hint (transient.el)

#+begin_src emacs-lisp
(use-package transient
  :commands (transient-define-prefix)
  :config
  (setq transient-show-popup -0.5)
  (transient-bind-q-to-quit)
  (define-key transient-map (kbd "<escape>") #'transient-quit-all)
  (define-key transient-sticky-map (kbd "ESC") #'transient-quit-all))
#+end_src

* Completion

The optimal way of using Emacs is through searching and narrowing
selection candidates.  Spend less time worrying about where things are
on the screen and more on how fast you can bring them into focus.  This
is, of course, a matter of realigning priorities, as we still wish to
control every aspect of the interface.

** Minibuffer (minibuffer.el)

#+begin_src emacs-lisp
(use-package minibuffer
  :straight (:type built-in)
  :config
  (require 'ace-minibuffer)
  (setq completion-styles '(orderless flex)) ; Handle it to `orderless.el'
  (setq completion-category-defaults nil)
  (setq completion-cycle-threshold 3)
  (setq completion-flex-nospace nil)
  (setq completion-pcm-complete-word-inserts-delimiters t)
  (setq completion-pcm-word-delimiters "-_./:| ")
  (setq completion-show-help nil)
  (setq completion-auto-help nil)
  (setq completion-ignore-case t)
  (setq-default case-fold-search t)   ; For general regexp
  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t)
  (setq enable-recursive-minibuffers t)
  (setq read-answer-short t)
  (setq resize-mini-windows t)
  (setq minibuffer-eldef-shorten-default t)
  (setq echo-keystrokes 0.25)           ; from the C source code
  (file-name-shadow-mode 1)
  (minibuffer-depth-indicate-mode 1)
  (minibuffer-electric-default-mode 1)
  (add-hook 'minibuffer-setup-hook (lambda () (keyboard-translate ?\C-i ?\H-z)))
  (add-hook 'minibuffer-exit-hook (lambda () (keyboard-translate ?\C-i ?\C-i)))
  (let ((map minibuffer-local-map))
    (define-key map (kbd "H-z") #'backward-char)
    (define-key map (kbd "C-o") #'forward-char)
    (define-key map (kbd "C-u") #'kill-whole-line)
    (define-key map (kbd "C-w") #'backward-kill-word)))
#+end_src

** Incremental narrowing (vertico.el)

A minimalistic completion UI.

#+begin_src emacs-lisp
(use-package vertico
  :defer t
  :init
  (vertico-mode 1)
  (set-face-attribute 'vertico-current nil :inherit 'ace/pulse-line)
  (advice-add 'vertico--resize-window :override #'ignore))
#+end_src

** Completion style (orderless.el)

#+begin_src emacs-lisp
(use-package orderless
  :config
  (require 'ace-orderless)
  (setq orderless-component-separator " +")
  (setq orderless-matching-styles
        '(ace/pinyin-build-regexp-string
          orderless-strict-leading-initialism
          orderless-prefixes
          orderless-regexp
          orderless-literal))
  (setq orderless-style-dispatchers
        '(ace/orderless-literal-dispatcher
          ace/orderless-initialism-dispatcher
          ace/orderless-pinyin-dispatcher))
  (define-key minibuffer-local-completion-map "SPC" nil))
#+end_src

** Completion hint (marginalia.el)

This is a utility jointly developed by Daniel Mendler and Omar Antolín
Camarena that provides annotations to completion candidates.  It is
meant to be framework-agnostic, so it works with Selectrum, Icomplete
vertical, and Embark (since 2020-12-20, the latter has become my choice
for visualising the standard completion framework's output

#+begin_src emacs-lisp
(use-package marginalia
  :after minibuffer
  :config
  (setq marginalia-annotators
        '(marginalia-annotators-heavy
          marginalia-annotators-light))
  (marginalia-mode))
#+end_src

** Minibuffer commands (consult.el)

#+begin_src emacs-lisp
(use-package consult
  :init
  (with-eval-after-load 'evil
    (evil-define-key '(normal visual) global-map "C-s" #'consult-isearch))
  (setq register-preview-delay 0.2)
  (setq register-preview-function #'consult-register-format)
  (advice-add #'register-preview :override #'consult-register-window))
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)
  :defer t
  :config
  (define-key global-map (kbd "C-s") 'consult-isearch)
  (define-key global-map (kbd "C-r") 'consult-isearch)
  (setq consult-line-numbers-widen t)
  (setq completion-in-region-function #'consult-completion-in-region)
  (setq consult-async-min-input 3)
  (setq consult-async-input-debounce 0.5)
  (setq consult-async-input-throttle 0.8)
  (setq consult-narrow-key ">")

(use-package ace-consult
  :straight nil
  :config
  (setq ace/consult-command-centre-list
        '(consult-line
          consult-mark
          consult-outline
          consult-project-imenu))
  (setq ace/consult-command-top-list '())
  (ace/consult-set-up-hooks-mode 1)
  ;; make sure `C-i/o' can jump between
  (dolist (cmd '(consult-line
                 consult-outline
                 consult-imenu))
    (evil-add-command-properties cmd :jump t)))
#+end_src

** Minibuffer actions (embark.el)

#+begin_src emacs-lisp
(use-package embark
  :config
  (setq embark-collect-initial-view-alist
        '((file . list)
          (buffer . list)
          (symbol . list)
          (line . list)
          (xref-location . list)
          (kill-ring . zebra)
          (t . list)))
  (setq embark-quit-after-action t)
  (setq embark-key-action-separator (propertize " · " 'face 'shadow))
  (setq embark-action-indicator
        (let ((act (propertize "Act" 'face 'success)))
          (cons act (concat act " on '%s'"))))
  (setq embark-become-indicator (propertize "Become" 'face 'warning))
  (define-key global-map (kbd "C-.") #'embark-act)
  (let ((map minibuffer-local-map))
    (define-key map (kbd "C-.") #'embark-act)
    (define-key map (kbd "C-,") #'embark-become))
  (let ((map embark-collect-mode-map))
    (define-key map (kbd "C-.") #'embark-act)))

(use-package ace-embark
  :straight nil
  :after embark
  :config
  (ace/embark-extras-keymaps 1))
#+end_src

** Completion utils (ace-completing.el)

#+begin_src emacs-lisp
(use-package ace-completing
  :straight nil
  :config
  (define-key global-map (kbd "C-x d") #'ace/completing-word-ispell))
#+end_src

* Window / Buffer / Tab

I believe that Emacs' true power lies in its buffer management rather
than its multiplexing.  The latter becomes inefficient at scale, since
it tries to emulate the limitations of the real world, namely, the
placement of things on a desk.

By leveraging the power of the computer, we can use search methods to
easily reach any item.  There is no need to remain confined to the idea
of a finite space (screen real estate) that needs to be carefully
managed.

That granted, Emacs' multiplexing can be turned into a powerhouse as
well, covering everything from window placement rules, to the recording
of history and layouts, as well as directional or direct window
navigation.

** Window rules (window.el)

The =display-buffer-alist= is intended as a rule-set for controlling the
display of windows.  The objective is to create a more intuitive
workflow where targeted buffer groups or types are always shown in a
given location, on the premise that predictability improves usability.

For each buffer action in =display-buffer-alist= we can define several
functions for selecting the appropriate window.  These are executed in
sequence, but my usage thus far suggests that a simpler method is just
as effective for my case.

#+begin_src emacs-lisp
(use-package window
  :straight (:type built-in)
  :config
  (setq display-buffer-alist
        '(("\\*\\(Flymake\\|Messages\\|Backtrace\\|Warnings\\|Compile-Log\\|Custom\\)\\*"
            (display-buffer-in-side-window)
            (window-height . 0.3)
            (side . bottom))
          ("\\*.*\\([Ee]shell\\|shell\\|\\Help\\|helpful\\).*"
            (display-buffer-in-side-window)
            (window-width . 0.4)
            (side . right))
          ("\\*\\vc-\\(incoming\\|outgoing\\|Output\\|Register Preview\\).*"
            (display-buffer-at-bottom))))
  (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)
  ;; Disable window close when calling 'keyboard-escape-quit'
  (defadvice keyboard-escape-quit (around keep-windows activate)
    (let ((buffer-quit-function (lambda () ()))) ad-do-it)))
#+end_src

** Window Position (transpose-frame.el)

The =transpose-frame= library defines a set of commands for shifting the
layout of Emacs windows.  Rather than me describing how these work, I
strongly encourage you to read the "Commentary" section in the source
code.  Do it with =M-x find-library transpose-frame=.

#+begin_src emacs-lisp
(use-package transpose-frame)
#+end_src

** Directional window motions (windmove.el)

Windmove is also built into Emacs.  It provides functions for selecting
a window in any of the cardinal directions.  A decent addition to the
simpler =other-window= command (=C-x o= by default).

The =windmove-create-window= specifies what should happen when trying to
move past the edge of the frame.  The idea with this is to allow it to
create a new window with the contents of the current buffer.  I tried it
for a while but felt that the times it would interfere with my layout
where more than those it would actually speed up my workflow.

#+begin_src emacs-lisp
(setq windmove-create-window nil)    ; Emacs 27.1
#+end_src

** Tabs (ace-tab.el)

The =tab-bar= library, is best understood as the equivalent of "virtual desktops",
as these are used in most desktop environments or window managers. You can, for
example, have your current project on tab (workspace) 1, your email and news
reader on 2, music on 3, and so on.  Of course, this can also be achieved by
using separate frames for each of these, though I generally prefer working in a
single frame (plus you can define a window configuration or frameset in a
register).

For me tabs are useful as groups of buffers in a given window
configuration.  I do not want a persistent bar with buttons that
introduces extra visual clutter.  Switching to tabs is done through
completion, specifically =ace/tab-select-tab-dwim=.

All settings I configure here are meant to work in accordance with this
abstract conception of "tabs are work spaces".  Here are the main key
chords for =tab-bar= (they will all work properly if you keep the mode
active):

| Key     | Description                    |
|---------+--------------------------------|
| C-x t b | Open a buffer in a new tab     |
| C-x t d | Open a directory in a new tab  |
| C-x t f | Open a file in a new tab       |
| C-x t 0 | Close current tab              |
| C-x t 1 | Close all other tabs           |
| C-x t 2 | Open current buffer in new tab |

To keeps the overall aesthetics minimalist, I explicitly disable the
presentation of the tab bar, even though I still use its functionality.  The
problem with such a configuration is that we lose context: it is no longer
possible to determine the number of open tabs nor understand the position of the
current one in the list.

This is where Fritz Grabo's =tab-bar-echo-area.el= enters the fray: it
prints a message in the echo area showing the tab list, while it
highlights the current item.  So we can retain both our minimalism and
the contextuality a bar offers.  Simple, yet super effective!

These are consistent with the standard commands for handling windows and
accessing buffers/files in the "other window" (the =C-x 4 KEY= pattern).
There is also a command for giving a name to the current tab, accessed
via =C-x t r=, though I find I do not use it.

#+begin_src emacs-lisp
(use-package tab-bar
  :config
  (setq tab-bar-tab-choice "NewTab")
  (setq tab-bar-new-button-show nil)
  (setq tab-bar-close-button-show nil)
  (setq tab-bar-close-last-tab-choice 'tab-bar-mode-disable)
  (setq tab-bar-close-tab-select 'recent)
  (setq tab-bar-new-tab-choice t)
  (setq tab-bar-new-tab-to 'right)
  (setq tab-bar-position nil)
  (setq tab-bar-show nil)
  (setq tab-bar-tab-hints nil)
  (setq tab-bar-tab-name-function 'tab-bar-tab-name-all)
  (tab-bar-mode -1)
  (tab-bar-history-mode -1)
  (let ((map global-map))
    (define-key map (kbd "H-s-<tab>") #'tab-next)
    (define-key map (kbd "H-s-`") #'tab-previous))
  (custom-set-faces
   '(tab-bar ((t (:inherit nil :height 1.1))))
   '(tab-bar-tab ((t (:inherit tab-bar :underline nil :weight bold))))
   '(tab-bar-tab-inactive ((t (:inherit tab-bar :weight normal :height 1.0))))))

(use-package ace-tab
  :straight nil
  :config
  (let ((map global-map))
    (define-key map (kbd "C-x t h") #'ace/tab-tab-bar-toggle)
    (define-key map (kbd "C-x t t") #'ace/tab-select-tab-dwim)))

(use-package tab-bar-echo-area
  :config
  (tab-bar-echo-area-mode 1))
#+end_src

** Unique names for buffers (uniquify.el)

These settings make it easier to work with multiple buffers.  When two
buffers have the same name, Emacs will try to disambiguate them by
displaying their element of differentiation in accordance with the style
of =uniquify-buffer-name-style=.  While =uniquify-strip-common-suffix= will
remove the part of the file system path they have in common.

All such operations are reversed once an offending buffer is removed
from the list, allowing Emacs to revert to the standard of displaying
only the buffer's name.

#+begin_src emacs-lisp
(use-package uniquify
  :straight nil
  :config
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-strip-common-suffix t)
  (setq uniquify-after-kill-buffer-p t))
#+end_src

** Ibuffer and extras (ace-ibuffer.el)

=ibuffer.el= ships with Emacs and it provides a drop-in replacement for
=list-buffers=.  Compared to its counterpart, it allows for granular
control over the buffer list and is more powerful overall.

#+begin_src emacs-lisp
(use-package ibuffer
  :config
  (setq ibuffer-expert t)
  (setq ibuffer-display-summary nil)
  (setq ibuffer-use-other-window nil)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-movement-cycle nil)
  (setq ibuffer-default-sorting-mode 'filename/process)
  (setq ibuffer-use-header-line t)
  (setq ibuffer-default-shrink-to-minimum-size nil)
  (setq ibuffer-formats
        '((mark modified read-only locked " "
                (name 30 30 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " " filename-and-process)
          (mark " "
                (name 16 -1)
                " " filename)))
  (setq ibuffer-saved-filter-groups nil)
  (add-to-list 'ibuffer-never-show-predicates "^\\ ")
  (setq ibuffer-old-time 48)
  (add-hook 'ibuffer-mode-hook (lambda () (interactive) (hl-line-mode) (ibuffer-update 0)))
  (let ((map ibuffer-mode-map))
    (define-key map (kbd "* f") #'ibuffer-mark-by-file-name-regexp)
    (define-key map (kbd "* g") #'ibuffer-mark-by-content-regexp) ; "g" is for "grep"
    (define-key map (kbd "* n") #'ibuffer-mark-by-name-regexp)
    (define-key map (kbd "s n") #'ibuffer-do-sort-by-alphabetic)  ; "sort name" mnemonic
    (define-key map (kbd "/ g") #'ibuffer-filter-by-content)))
#+end_src

** Buffer name (uniquify.el)

These settings make it easier to work with multiple buffers.  When two
buffers have the same name, Emacs will try to disambiguate them by
displaying their element of differentiation in accordance with the style
of =uniquify-buffer-name-style=.  While =uniquify-strip-common-suffix= will
remove the part of the file system path they have in common.

All such operations are reversed once an offending buffer is removed
from the list, allowing Emacs to revert to the standard of displaying
only the buffer's name.

#+begin_src emacs-lisp
(use-package uniquify
  :straight nil
  :config
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-strip-common-suffix t)
  (setq uniquify-after-kill-buffer-p t))
#+end_src

** Scratch buffers (scratch.el)
This package will produce a buffer that matches the major mode of the
one you are currently in.  Use it with =M-x scratch=.  Doing that with a
prefix argument (=C-u=) will prompt for a major mode instead.  Simple yet
super effective!

The =prot/scratch-buffer-setup= simply adds some text in the buffer and
renames it appropriately for the sake of easier discovery.  I got the
idea of copying the region from [[https://gist.github.com/eev2/52edbfdb645e26aefec19226c0ca7ad0][a snippet shared by eev2 on GitHub]].

#+begin_src emacs-lisp
(use-package scratch
  :defer t
  :config
  (defun ace/scratch-buffer-setup ()
    "Add contents to `scratch' buffer and name it accordingly.
If region is active, add its contents to the new buffer."
    (let* ((mode major-mode)
           (string (format "Scratch buffer for: %s\n\n" mode))
           (region (with-current-buffer (current-buffer)
                     (if (region-active-p)
                         (buffer-substring-no-properties
                          (region-beginning)
                          (region-end)))
                     ""))
           (text (concat string region)))
      (when scratch-buffer
	      (save-excursion
          (insert text)
          (goto-char (point-min))
          (comment-region (point-at-bol) (point-at-eol)))
	      (forward-line 2))
      (rename-buffer (format "*Scratch for %s*" mode) t)))
  (add-hook 'scratch-create-buffer-hook #'ace/scratch-buffer-setup)
  (define-key global-map (kbd "C-c s") #'scratch))
#+end_src

* File management

Configuration about dired, lf, files, recentf etc.

** Dired (dired.el)

The directory editor abbreviated as "Dired" is a built-in tool that performs
file management operations inside of an Emacs buffer.  It is simply superb!

#+begin_src emacs-lisp
(use-package dired
  :straight (:type built-in)
  :config
  (with-eval-after-load 'doom-modeline
    (remove-hook 'dired-mode-hook #'doom-modeline-set-project-modeline))
  (setq large-file-warning-threshold nil)
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)
  (setq dired-dwim-target t)
  (setq dired-listing-switches "-AGhlv --group-directories-first --time-style=long-iso")
  (defun ace/dired-file-rename-eol ()
    (interactive)
    (end-of-line)
    (wdired-change-to-wdired-mode))
  (define-key dired-mode-map "I"  #'dired-insert-subdir)
  (define-key dired-mode-map "E"  #'dired-create-empty-file)
  (define-key dired-mode-map "i"  #'wdired-change-to-wdired-mode)
  (define-key dired-mode-map "a"  #'ace/dired-file-rename-eol)
  (define-key dired-mode-map "r"  #'revert-buffer)
  (define-key dired-mode-map "g"  #'beginning-of-buffer)
  (define-key dired-mode-map "G"  #'end-of-buffer)
  (define-key dired-mode-map "h"  #'dired-up-directory)
  (define-key dired-mode-map "v"  #'set-mark-command)
  (define-key dired-mode-map "."  #'dired-omit-mode))
#+end_src

** Wdired (wdired.el)

#+begin_src emacs-lisp
(use-package wdired
  :config
  (setq wdired-allow-to-change-permissions t)
  (setq wdired-create-parent-directories t))
#+end_src

** Lf (lf.el)

Lf means 'list files'. This package is a clone of the popular file manager
=ranger=, I wrote it on the basis of =ranger.el=. Compare to =ranger.el=, this package
only keeps features I wanted, and some sensible functionalities were added as
well. See details at: https://github.com/alexluigit/lf.el

#+begin_src emacs-lisp
(use-package lf
  :straight (lf :type git :host github :repo "alexluigit/lf.el")
  :config
  (setq lf-trash-dir-alist '(("/media/HDD/" . ".Trash/files") ("/media/Cloud/" . ".Trash/files")))
  (setq lf-show-icons t)
  (setq lf-completing-preview-position
        (lambda (info)
          (cons (/ (- (plist-get info :parent-frame-width)
                      (plist-get info :posframe-width)) 2)
                (or (frame-parameter nil 'internal-border-width) 30))))
  (lf-override-dired-mode)
  (lf-completing-preview-mode)
  (transient-define-prefix ace/lf-go ()
    "Lf `lf-go' keybind."
    ["Directory"
     ("h" "Home" (lambda () (interactive) (lf-find-file "~/")))
     ("u" "Emacs User Dir" (lambda () (interactive) (lf-find-file user-emacs-directory)))
     ("c" "Code" (lambda () (interactive) (lf-find-file "~/Dev")))
     ("d" "Downloads" (lambda () (interactive) (lf-find-file "~/Downloads")))
     ("p" "Wallpaper" (lambda () (interactive) (lf-find-file "~/Pictures/wallpaper")))
     ("m" "Drives (media)" (lambda () (interactive) (lf-find-file "/media")))
     ("t" "Trash" (lambda () (interactive) (lf-find-file "~/.local/share/Trash/files")))]
    ["Navigation"
     ("g" "Top" lf-go-top)
     ("N" "Next subdir" dired-next-subdir)
     ("P" "Prev subdir" dired-prev-subdir)])
  (define-key evil-normal-state-map "-" #'lf)
  (define-key lf-mode-map "g" #'ace/lf-go))
#+end_src

** Highlighting (diredfl.el)

Additional syntax highlighting in dired / lf buffer.

#+begin_src emacs-lisp
(use-package diredfl
  :hook (dired-mode . diredfl-mode))
#+end_src

** Recent files (recentf.el)

#+begin_src emacs-lisp
(use-package recentf
  :straight (:type built-in)
  :config
  (recentf-mode 1))
#+end_src

** Trash (trashed.el)

=trashed= applies the principles of =dired= to the management of the user's
filesystem trash.  Use =C-h m= to see the docs and keybindings for its
major mode.

Basically, its interaction model is as follows:

- =m= to mark for some deferred action, such as =D= to delete, =R= to restore.
- =t= to toggle the status of all items as marked.  Use this without marks
  to =m= (mark) all items, then call a deferred action to operate on them.
- =d= to mark for permanent deletion.
- =r= to mark for restoration.
- =x= to execute these special marks.

#+begin_src emacs-lisp
;; (use-package trashed
;;   :config
;;   (setq trashed-action-confirmer 'y-or-n-p)
;;   (setq trashed-use-header-line t)
;;   (setq trashed-sort-key '("Date deleted" . t))
;;   (setq trashed-date-format "%Y-%m-%d %H:%M:%S"))
#+end_src

* Org mode

Org mode setup.

** Org (org.el)

#+begin_src emacs-lisp
(use-package org
  :defer t
  :straight (:type built-in)
  :hook
  (org-mode . ace/font-org-setup)
  (org-tab-first . org-end-of-line)
  :config
  (setq org-src-window-setup 'split-window-right)
  (setq org-adapt-indentation nil)
  (setq org-hide-leading-stars t)
  (setq org-startup-folded t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-edit-src-content-indentation 0)
  (setq org-ellipsis " ▾")
  (setq org-hide-emphasis-markers t)
  (setq org-agenda-start-with-log-mode t)
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (haskell . t)))
  (push '("conf-unix" . conf-unix) org-src-lang-modes)
  :bind
  (:map org-mode-map
        ("C-'" . org-edit-special)
        ("C-o" . forward-char)
        ("<C-return>" . l)
        ("<C-S-return>" . l)
        ("C-c S-l" . org-toggle-link-display)
        ("C-c C-S-l" . org-insert-last-stored-link)
        :map org-src-mode-map
        ("C-'" . org-edit-src-exit)))
#+end_src

** Bullet (org-superstar.el)

#+begin_src emacs-lisp
(use-package org-superstar
  :defer t
  :config
  (setq org-superstar-remove-leading-stars t)
  (setq org-superstar-headline-bullets-list '("◉" "○" "●" "○" "●" "○" "●"))
  :hook
  (org-mode . org-superstar-mode))
#+end_src

** Source Block (org-tempo.el)

#+begin_src emacs-lisp
(use-package org-tempo ; this is needed as of Org 9.2
  :straight (:type built-in)
  :config
  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("hk" . "src haskell"))
  (add-to-list 'org-structure-template-alist '("py" . "src python")))
#+end_src

** Habit (org-habit.el)

#+begin_src emacs-lisp
(use-package org-habit
  :defer t
  :straight (:type built-in)
  :straight nil
  :config
  (add-to-list 'org-modules 'org-habit)
  (setq org-habit-graph-column 60))
#+end_src

* Utils
** Vterm

#+begin_src emacs-lisp
(use-package vterm
  :config
  (setq vterm-always-compile-module t)
  (defun ace/vterm-send-key (key &optional shift meta ctrl)
    "Send KEY to libvterm with optional modifiers SHIFT, META and CTRL."
    (deactivate-mark)
    (when vterm--term
      (let ((inhibit-redisplay t)
            (inhibit-read-only t))
        (when (and (not (symbolp last-input-event)) shift (not meta) (not ctrl))
          (setq key (upcase key)))
        (vterm--update vterm--term key shift meta ctrl)
        (setq vterm--redraw-immididately t)
        (when (not (eq evil-state 'insert))
          (accept-process-output vterm--process vterm-timer-delay nil t)))))
  (defun ace/vterm-hook ()
    (evil-define-key 'insert 'local [escape] #'vterm-send-escape)
    (evil-define-key 'insert 'local (kbd "<C-return>") '(lambda () (interactive) (vterm-send-key "<f5>")))
    (evil-define-key 'insert 'local (kbd "C-i") '(lambda () (interactive) (vterm-send-key "<f6>")))
    (evil-define-key 'insert 'local (kbd "s-<f6>") '(lambda () (interactive) (vterm-yank)))
    (set (make-local-variable 'buffer-face-mode-face) 'fixed-pitch)
    (vterm-reset-cursor-point)
    (buffer-face-mode t))
  (advice-add 'vterm-send-key :override #'ace/vterm-send-key)
  :hook
  (vterm-mode . ace/vterm-hook))
#+end_src

** Epub reader (nov.el)

#+begin_src emacs-lisp
(use-package shrface
  :defer t
  :config
  (shrface-basic)
  (shrface-trial)
  (add-to-list 'shr-external-rendering-functions
               '(span . shrface-tag-span))
  (shrface-default-keybindings) ; setup default keybindings
  (setq shrface-href-versatile t))

(use-package nov
  :defer t
  :init
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
  (add-hook 'nov-mode-hook 'ace/nov-font-setup)
  (add-hook 'nov-mode-hook #'shrface-mode)
  :config
  (advice-add 'nov-render-title :override #'ignore)

  (defun doom-modeline-segment--nov-info ()
    (concat
     " "
     (propertize
      (cdr (assoc 'creator nov-metadata))
      'face 'doom-modeline-project-parent-dir)
     " "
     (cdr (assoc 'title nov-metadata))
     " "
     (propertize
      (format "%d/%d"
              (1+ nov-documents-index)
              (length nov-documents))
      'face 'doom-modeline-info)))

  (defun ace/nov-font-setup ()
    (setq-local mode-line-format
                `((:eval
                    (doom-modeline-segment--workspace-name))
                  (:eval
                    (doom-modeline-segment--window-number))
                  (:eval
                    (doom-modeline-segment--nov-info))
                  ,(propertize
                    " %P "
                    'face 'doom-modeline-buffer-minor-mode)
                  ,(propertize
                    " "
                    'face (if (doom-modeline--active) 'mode-line 'mode-line-inactive)
                    'display `((space
                                :align-to
                                (- (+ right right-fringe right-margin)
                                    ,(* (let ((width (doom-modeline--font-width)))
                                          (or (and (= width 1) 1)
                                              (/ width (frame-char-width) 1.0)))
                                        (string-width
                                        (format-mode-line (cons "" '(:eval (doom-modeline-segment--major-mode))))))))))
                    (:eval (doom-modeline-segment--major-mode))))
    (require 'shrface)
    (setq nov-shr-rendering-functions '((img . nov-render-img) (title . nov-render-title) (b . shr-tag-b)))
    (setq nov-shr-rendering-functions
          (append nov-shr-rendering-functions shr-external-rendering-functions))))
#+end_src

** Version control (magit.el)

#+begin_src emacs-lisp
(setq vc-follow-symlinks t)

(use-package magit
  :defer t
  :config
  (setq magit-define-global-key-bindings nil)
  (define-key magit-mode-map (kbd "`") #'magit-diff-show-or-scroll-up)
  (define-key magit-diff-mode-map (kbd "`") #'scroll-up)
  (require 'git-commit)
  (setq git-commit-summary-max-length 50)
  (setq git-commit-known-pseudo-headers
        '("Signed-off-by"
          "Acked-by"
          "Modified-by"
          "Cc"
          "Suggested-by"
          "Reported-by"
          "Tested-by"
          "Reviewed-by"))
  (setq git-commit-style-convention-checks
        '(non-empty-second-line
          overlong-summary-line))
  (require 'magit-diff)
  (define-key magit-diff-section-base-map (kbd "<C-return>") #'magit-diff-visit-file-other-window)
  (setq magit-diff-refine-hunk t)
  (require 'magit-repos)
  (setq magit-repository-directories
        '(("~/Dev" . 1))))

(use-package git-gutter
  :config
  (custom-set-variables
   '(git-gutter:modified-sign "⏽")
   '(git-gutter:added-sign "⏽")
   '(git-gutter:deleted-sign "⏽")))

(use-package ediff
  :config
  (setq ediff-keep-variants nil)
  (setq ediff-make-buffers-readonly-at-startup nil)
  (setq ediff-merge-revisions-with-ancestor t)
  (setq ediff-show-clashes-only t)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; Tweak those for safer identification and removal
  (setq ediff-combination-pattern
        '("<<<<<<< ace-ediff-combine Variant A" A
          ">>>>>>> ace-ediff-combine Variant B" B
          "####### ace-ediff-combine Ancestor" Ancestor
          "======= ace-ediff-combine End"))

  (defun ace/ediff-flush-combination-pattern ()
    "Remove my custom `ediff-combination-pattern' markers.

This is a quick-and-dirty way to get rid of the markers that are
left behind by `smerge-ediff' when combining the output of two
diffs.  While this could be automated via a hook, I am not yet
sure this is a good approach."
    (interactive)
    (flush-lines ".*ace-ediff.*" (point-min) (point-max) nil)))
;; (use-package forge)
#+end_src

** Project management (project.el)

#+begin_src emacs-lisp
(use-package project
  :straight (:type built-in)
  :config
  (setq project-switch-commands
        '((?f "File" project-find-file)
          (?s "Subdir" ace/project-find-subdir)
          (?g "Grep" project-find-regexp)
          (?d "Dired" project-dired)
          (?b "Buffer" project-switch-to-buffer)
          (?q "Query replace" project-query-replace-regexp)
          (?t "Tag switch" ace/project-retrieve-tag)
          (?m "Magit" ace/project-magit-status)
          (?l "Log VC" ace/project-commit-log)
          (?e "Eshell" project-eshell)))
  :bind-keymap
  ("H-." . project-prefix-map))

(use-package ace-project
  :straight nil
  :config
  (setq ace/project-project-roots '("~/Dev/" "~/"))
  (setq ace/project-commit-log-limit 25)
  (setq ace/project-large-file-lines 1000)
  (let ((map global-map))
    (define-key map (kbd "C-x p DEL") #'ace/project-remove-project)
    (define-key map (kbd "C-x p l") #'ace/project-commit-log)
    (define-key map (kbd "C-x p m") #'ace/project-magit-status)
    (define-key map (kbd "C-x p s") #'ace/project-find-subdir)
    (define-key map (kbd "C-x p t") #'ace/project-retrieve-tag)))
#+end_src

* Development

Packages or custom functions for development.

** Major mode

#+begin_src emacs-lisp
(use-package lua-mode
  :defer t)

(use-package yaml-mode
  :defer t)

(use-package web-mode
  :defer t
  :config
  (define-derived-mode ace/vue-mode web-mode "ace/vue"
    "A major mode derived from web-mode, for editing .vue files with LSP support.")
  :hook
  (web-mode . (lambda ()
                (setq web-mode-markup-indent-offset 2)
                (setq web-mode-code-indent-offset 2)
                (setq web-mode-script-padding 0)))
  :mode ("\\.vue\\'" . ace/vue-mode))
#+end_src

** Language server protocol (lsp-mode.el)

#+begin_src emacs-lisp
(use-package lsp-mode
  :defer t
  :config
  (lsp-register-custom-settings '(("vetur.ignoreProjectWarning" t t)))
  (dolist (dir '("[/\\\\]\\.cache" "[/\\\\]elpa$"))
    (push dir lsp-file-watch-ignored-directories))
  (dolist (hook '(
                  sh-mode-hook
                  lua-mode-hook
                  haskell-mode-hook
                  web-mode-hook
                  typescript-mode-hook
                  ))
    (add-hook hook #'lsp-deferred))
  (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols)))

(use-package lsp-tailwindcss)

(use-package lsp-ui
  :defer t
  :config
  (setq lsp-ui-sideline-show-code-actions nil)
  (setq lsp-ui-doc-position 'bottom)
  :hook
  (lsp-mode . lsp-ui-mode))

(use-package lsp-treemacs
  :defer t)
#+end_src

** Auto completion (company-mode.el)

#+begin_src emacs-lisp
(use-package company
  :defer t
  :hook
  (after-init . global-company-mode)
  :config
  (setq company-idle-delay 0.0)
  (let ((map company-active-map))
    (define-key map (kbd "<tab>") #'company-complete-selection)
    (define-key map (kbd "C-p") #'company-select-previous)
    (define-key map (kbd "C-n") #'company-select-next))
  (setq company-idle-delay 0.0)
  (let ((map company-active-map))
    (define-key map (kbd "<tab>") #'company-complete-selection)
    (define-key map (kbd "C-p") #'company-select-previous)
    (define-key map (kbd "C-n") #'company-select-next)))
#+end_src

** Flycheck

#+begin_src emacs-lisp
;; (use-package flymake
;;   :config
;;   (setq flymake-fringe-indicator-position 'left-fringe)
;;   (setq flymake-suppress-zero-counters t)
;;   (setq flymake-start-on-flymake-mode t)
;;   (setq flymake-no-changes-timeout nil)
;;   (setq flymake-start-on-save-buffer t)
;;   (setq flymake-proc-compilation-prevents-syntax-check t)
;;   (setq flymake-wrap-around nil)
;;   (let ((map flymake-mode-map))
;;     (define-key map (kbd "C-c ! s") #'flymake-start)
;;     (define-key map (kbd "C-c ! d") #'flymake-show-diagnostics-buffer)
;;     (define-key map (kbd "C-c ! n") #'flymake-goto-next-error)
;;     (define-key map (kbd "C-c ! p") #'flymake-goto-prev-error)))

;; (use-package flymake-diagnostic-at-point
;;  :config
;; 	(setq flymake-diagnostic-at-point-display-diagnostic-function
;; 			  'flymake-diagnostic-at-point-display-minibuffer))
#+end_src

** Comment (evil-nerd-commenter.el)

Emacs' built in commenting functionality =comment-dwim= (usually bound to =M-;=) doesn't always comment things in the way you might expect so we use [[https://github.com/redguardtoo/evil-nerd-commenter][evil-nerd-commenter]] to provide a more familiar behavior.  I've bound it to =s-/= since other editors sometimes use this binding but you could also replace Emacs' =M-;= binding with this command.

#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :defer t)
#+end_src

** Colorizer (rainbow-mode.el)

#+begin_src emacs-lisp
(use-package rainbow-mode
  :defer t
  :hook
  (prog-mode . rainbow-mode))
#+end_src

** Formatter (format-all.el)

#+begin_src emacs-lisp
(use-package format-all
  :defer t)
#+end_src

* Keybindings

This section is for my finalized global keybinds which contains super key
combination and leader key in various modes. To ensure other config has been
fully loaded, I put this section at the end of my config file.

** Super key

#+begin_src emacs-lisp
(let ((map global-map))
  (define-key map (kbd "s-/") #'evilnc-comment-or-uncomment-lines)
  (define-key map (kbd "s-u") #'scroll-down)
  (define-key map (kbd "s-e") #'scroll-up)
  (define-key map (kbd "s-n") #'ace/simple-winmove-r/d)
  (define-key map (kbd "s-p") #'ace/simple-winmove-l/u)
  (define-key map (kbd "s-i") #'next-buffer)
  (define-key map (kbd "s-o") #'previous-buffer)
  (define-key map (kbd "s-h") (lambda () (interactive) (split-window-right) (windmove-right)))
  (define-key map (kbd "s-v") (lambda () (interactive) (split-window-below) (windmove-down)))
  (define-key map (kbd "s-a") #'ibuffer)
  (define-key map (kbd "s-w") #'save-buffer)
  (define-key map (kbd "s-k") #'kill-current-buffer)
  (define-key map (kbd "s-f") #'ace/completing-buffers-major-mode)
  (define-key map (kbd "s-m") #'ace/simple-monocle)
  (define-key map (kbd "s-q") #'ace/simple-kill-window-current)
  (define-key map (kbd "s-=") #'balance-windows-area)
  (define-key map (kbd "s-z") #'window-toggle-side-windows)
  (define-key map (kbd "s-l") #'consult-line)
  (define-key map (kbd "s-r") #'ace/ibuffer-buffers-vc-root)
  (define-key map (kbd "s-s") #'consult-outline)
  (define-key map (kbd "s-t") #'vterm)
  (define-key map (kbd "s-x") #'execute-extended-command)
  (define-key map (kbd "s-<backspace>") (lambda () (interactive) (let ((inhibit-read-only t)) (erase-buffer)))))
#+end_src

** Leader key

I believe transient provides a better interface for complex (usually with
prefix) keybindings. This package is actually a part of =magit=, serve as the key
chords interface. For example, you type =c= in magit, it will give you a menu
window with a lot of hints about what command/action you might want to execute
next. Comparing to =which-key=, which is a similar project, it has better
classification of commands and better UI overall.

#+begin_src emacs-lisp
(transient-define-prefix ace/leader-find ()
  "file open"
  ["Find File"
   [("p" "Find file in project" project-find-file)
    ("u" "Find user dir file" ace/completing-file-in-user-dirs)
    ("r" "Recent file" ace/completing-recentf)]])

(transient-define-prefix ace/leader-consult ()
  "Consult commands"
  ["Consult"
   [("g" "Grep" consult-grep)
    ("k" "Keep lines" consult-keep-lines)
    ("f" "Focus lines" consult-focus-lines)
    ("m" "Marks" consult-mark)
    ("i" "isearch" consult-isearch)
    ("I" "imenu" consult-project-imenu)
    ("r" "Register" consult-register)
    ("k" "Cycle kill-ring" consult-yank)
    ("M" "Minor mode menu" consult-minor-mode-menu)
    ("c" "Mode command" consult-mode-command)
    ("C" "Complex commands" consult-complex-command)]])

(transient-define-prefix ace/leader-project ()
  "Project commands"
  ["Project commands"
   [("p" "Open/Switch project" project-switch-project)
    ("r" "Rg on project" ace/rg-project-dwim)]])

(transient-define-prefix ace/leader-eval ()
  "Eval (elisp) commands"
  ["Eval"
   [("e" "Eval last s-expression" eval-last-sexp)
    ("x" "Eval expression" eval-expression)
    ("f" "Eval defun" eval-defun)
    ("b" "Eval buffer" eval-buffer)
    ("r" "Elisp repl" ielm)]])

(transient-define-prefix ace/leader-tab ()
  "Util commands"
  ["Tab"
   [("tt" "New/Select tab" ace/tab-select-tab-dwim)
    ("tx" "Close tab" tab-close)
    ("tl" "Toggle tab line" ace/tab-tab-bar-toggle)]])

(transient-define-prefix ace/leader-window ()
  "Util commands"
  ["Window"
   [("f" "flop frame windows" flop-frame)
    ("r" "rotate frame windows" rotate-frame-clockwise)
    ("h" "Move window left" evil-window-move-far-left)
    ("l" "Move window right" evil-window-move-far-right)]])

(transient-define-prefix ace/leader-git ()
  "Util commands"
  ["Git"
   [("h" "Show hunks" git-gutter-mode)
    ("g" "Open magit client" magit-status)]])

(transient-define-prefix ace/leader-utils ()
  "Util commands"
  ["Utils"
   [("m"   "Murl" ace/completing-murl)
    ("r"   "Rg on file" rg-dwim-current-file)
    ("f"   "Format file" format-all-buffer)
    ("R"   "Rename file" ace/simple-rename-file-and-buffer)]])

(transient-define-prefix ace/leader ()
  "Leader keybind"
  ["Ace Leader Commands"
   [("f" "Finder" ace/leader-find)]
   [("c" "Consult" ace/leader-consult)]
   [("p" "Project" ace/leader-project)]
   [("e" "Eval" ace/leader-eval)]
   [("w" "Window" ace/leader-window)]
   [("t" "Tab" ace/leader-tab)]
   [("g" "Git" ace/leader-git)]
   [("u" "Utils" ace/leader-utils)]]
  ["Shortcuts"
   [("`"   "Edit emacs config" ace/init-edit-config)]
   [("."   "Find file in dotfiles" (lambda () (interactive) (ace/completing-file-in-user-dirs t)))]
   [("SPC" "Find file in project" project-find-file)]])

(with-eval-after-load 'dired (define-key dired-mode-map (kbd "SPC") #'ace/leader))
(with-eval-after-load 'magit (define-key magit-mode-map (kbd "SPC") #'ace/leader))
(with-eval-after-load 'evil
    (define-key evil-normal-state-map (kbd "SPC") #'ace/leader)
    (define-key evil-visual-state-map (kbd "SPC") #'ace/leader))
#+end_src
